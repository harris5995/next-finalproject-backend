
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Tops
 * 
 */
export type Tops = $Result.DefaultSelection<Prisma.$TopsPayload>
/**
 * Model Bottoms
 * 
 */
export type Bottoms = $Result.DefaultSelection<Prisma.$BottomsPayload>
/**
 * Model Shoes
 * 
 */
export type Shoes = $Result.DefaultSelection<Prisma.$ShoesPayload>
/**
 * Model Accessories
 * 
 */
export type Accessories = $Result.DefaultSelection<Prisma.$AccessoriesPayload>
/**
 * Model Accs
 * 
 */
export type Accs = $Result.DefaultSelection<Prisma.$AccsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.tops`: Exposes CRUD operations for the **Tops** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tops
    * const tops = await prisma.tops.findMany()
    * ```
    */
  get tops(): Prisma.TopsDelegate<ExtArgs>;

  /**
   * `prisma.bottoms`: Exposes CRUD operations for the **Bottoms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bottoms
    * const bottoms = await prisma.bottoms.findMany()
    * ```
    */
  get bottoms(): Prisma.BottomsDelegate<ExtArgs>;

  /**
   * `prisma.shoes`: Exposes CRUD operations for the **Shoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shoes
    * const shoes = await prisma.shoes.findMany()
    * ```
    */
  get shoes(): Prisma.ShoesDelegate<ExtArgs>;

  /**
   * `prisma.accessories`: Exposes CRUD operations for the **Accessories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accessories
    * const accessories = await prisma.accessories.findMany()
    * ```
    */
  get accessories(): Prisma.AccessoriesDelegate<ExtArgs>;

  /**
   * `prisma.accs`: Exposes CRUD operations for the **Accs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accs
    * const accs = await prisma.accs.findMany()
    * ```
    */
  get accs(): Prisma.AccsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.3.1
   * Query Engine version: 61e140623197a131c2a6189271ffee05a7aa9a59
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Tops: 'Tops',
    Bottoms: 'Bottoms',
    Shoes: 'Shoes',
    Accessories: 'Accessories',
    Accs: 'Accs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'tops' | 'bottoms' | 'shoes' | 'accessories' | 'accs'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Tops: {
        payload: Prisma.$TopsPayload<ExtArgs>
        fields: Prisma.TopsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          findFirst: {
            args: Prisma.TopsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          findMany: {
            args: Prisma.TopsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>[]
          }
          create: {
            args: Prisma.TopsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          createMany: {
            args: Prisma.TopsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TopsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          update: {
            args: Prisma.TopsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          deleteMany: {
            args: Prisma.TopsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TopsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TopsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TopsPayload>
          }
          aggregate: {
            args: Prisma.TopsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTops>
          }
          groupBy: {
            args: Prisma.TopsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TopsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopsCountArgs<ExtArgs>,
            result: $Utils.Optional<TopsCountAggregateOutputType> | number
          }
        }
      }
      Bottoms: {
        payload: Prisma.$BottomsPayload<ExtArgs>
        fields: Prisma.BottomsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BottomsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BottomsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          findFirst: {
            args: Prisma.BottomsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BottomsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          findMany: {
            args: Prisma.BottomsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>[]
          }
          create: {
            args: Prisma.BottomsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          createMany: {
            args: Prisma.BottomsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BottomsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          update: {
            args: Prisma.BottomsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          deleteMany: {
            args: Prisma.BottomsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BottomsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BottomsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BottomsPayload>
          }
          aggregate: {
            args: Prisma.BottomsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBottoms>
          }
          groupBy: {
            args: Prisma.BottomsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BottomsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BottomsCountArgs<ExtArgs>,
            result: $Utils.Optional<BottomsCountAggregateOutputType> | number
          }
        }
      }
      Shoes: {
        payload: Prisma.$ShoesPayload<ExtArgs>
        fields: Prisma.ShoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          findFirst: {
            args: Prisma.ShoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          findMany: {
            args: Prisma.ShoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>[]
          }
          create: {
            args: Prisma.ShoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          createMany: {
            args: Prisma.ShoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          update: {
            args: Prisma.ShoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          deleteMany: {
            args: Prisma.ShoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShoesPayload>
          }
          aggregate: {
            args: Prisma.ShoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShoes>
          }
          groupBy: {
            args: Prisma.ShoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoesCountArgs<ExtArgs>,
            result: $Utils.Optional<ShoesCountAggregateOutputType> | number
          }
        }
      }
      Accessories: {
        payload: Prisma.$AccessoriesPayload<ExtArgs>
        fields: Prisma.AccessoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessoriesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessoriesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          findFirst: {
            args: Prisma.AccessoriesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessoriesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          findMany: {
            args: Prisma.AccessoriesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>[]
          }
          create: {
            args: Prisma.AccessoriesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          createMany: {
            args: Prisma.AccessoriesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccessoriesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          update: {
            args: Prisma.AccessoriesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          deleteMany: {
            args: Prisma.AccessoriesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccessoriesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccessoriesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessoriesPayload>
          }
          aggregate: {
            args: Prisma.AccessoriesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccessories>
          }
          groupBy: {
            args: Prisma.AccessoriesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccessoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessoriesCountArgs<ExtArgs>,
            result: $Utils.Optional<AccessoriesCountAggregateOutputType> | number
          }
        }
      }
      Accs: {
        payload: Prisma.$AccsPayload<ExtArgs>
        fields: Prisma.AccsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          findFirst: {
            args: Prisma.AccsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          findMany: {
            args: Prisma.AccsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>[]
          }
          create: {
            args: Prisma.AccsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          createMany: {
            args: Prisma.AccsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          update: {
            args: Prisma.AccsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          deleteMany: {
            args: Prisma.AccsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccsPayload>
          }
          aggregate: {
            args: Prisma.AccsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccs>
          }
          groupBy: {
            args: Prisma.AccsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccsCountArgs<ExtArgs>,
            result: $Utils.Optional<AccsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tops: number
    bottoms: number
    shoes: number
    accessories: number
    accs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tops?: boolean | UserCountOutputTypeCountTopsArgs
    bottoms?: boolean | UserCountOutputTypeCountBottomsArgs
    shoes?: boolean | UserCountOutputTypeCountShoesArgs
    accessories?: boolean | UserCountOutputTypeCountAccessoriesArgs
    accs?: boolean | UserCountOutputTypeCountAccsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBottomsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShoesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ShoesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccessoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccessoriesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string | null
    email: string
    password: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    tops?: boolean | User$topsArgs<ExtArgs>
    bottoms?: boolean | User$bottomsArgs<ExtArgs>
    shoes?: boolean | User$shoesArgs<ExtArgs>
    accessories?: boolean | User$accessoriesArgs<ExtArgs>
    accs?: boolean | User$accsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    tops?: boolean | User$topsArgs<ExtArgs>
    bottoms?: boolean | User$bottomsArgs<ExtArgs>
    shoes?: boolean | User$shoesArgs<ExtArgs>
    accessories?: boolean | User$accessoriesArgs<ExtArgs>
    accs?: boolean | User$accsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tops: Prisma.$TopsPayload<ExtArgs>[]
      bottoms: Prisma.$BottomsPayload<ExtArgs>[]
      shoes: Prisma.$ShoesPayload<ExtArgs>[]
      accessories: Prisma.$AccessoriesPayload<ExtArgs>[]
      accs: Prisma.$AccsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: number
      name: string | null
      email: string
      password: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tops<T extends User$topsArgs<ExtArgs> = {}>(args?: Subset<T, User$topsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findMany'> | Null>;

    bottoms<T extends User$bottomsArgs<ExtArgs> = {}>(args?: Subset<T, User$bottomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findMany'> | Null>;

    shoes<T extends User$shoesArgs<ExtArgs> = {}>(args?: Subset<T, User$shoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    accessories<T extends User$accessoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$accessoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findMany'> | Null>;

    accs<T extends User$accsArgs<ExtArgs> = {}>(args?: Subset<T, User$accsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.tops
   */
  export type User$topsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    where?: TopsWhereInput
    orderBy?: TopsOrderByWithRelationInput | TopsOrderByWithRelationInput[]
    cursor?: TopsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopsScalarFieldEnum | TopsScalarFieldEnum[]
  }


  /**
   * User.bottoms
   */
  export type User$bottomsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    where?: BottomsWhereInput
    orderBy?: BottomsOrderByWithRelationInput | BottomsOrderByWithRelationInput[]
    cursor?: BottomsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BottomsScalarFieldEnum | BottomsScalarFieldEnum[]
  }


  /**
   * User.shoes
   */
  export type User$shoesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    where?: ShoesWhereInput
    orderBy?: ShoesOrderByWithRelationInput | ShoesOrderByWithRelationInput[]
    cursor?: ShoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoesScalarFieldEnum | ShoesScalarFieldEnum[]
  }


  /**
   * User.accessories
   */
  export type User$accessoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    where?: AccessoriesWhereInput
    orderBy?: AccessoriesOrderByWithRelationInput | AccessoriesOrderByWithRelationInput[]
    cursor?: AccessoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessoriesScalarFieldEnum | AccessoriesScalarFieldEnum[]
  }


  /**
   * User.accs
   */
  export type User$accsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    where?: AccsWhereInput
    orderBy?: AccsOrderByWithRelationInput | AccsOrderByWithRelationInput[]
    cursor?: AccsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccsScalarFieldEnum | AccsScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Tops
   */

  export type AggregateTops = {
    _count: TopsCountAggregateOutputType | null
    _avg: TopsAvgAggregateOutputType | null
    _sum: TopsSumAggregateOutputType | null
    _min: TopsMinAggregateOutputType | null
    _max: TopsMaxAggregateOutputType | null
  }

  export type TopsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TopsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TopsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type TopsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type TopsCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    url: number
    brand: number
    color: number
    size: number
    occasion: number
    material: number
    _all: number
  }


  export type TopsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TopsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TopsMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type TopsMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type TopsCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
    _all?: true
  }

  export type TopsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tops to aggregate.
     */
    where?: TopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tops to fetch.
     */
    orderBy?: TopsOrderByWithRelationInput | TopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tops
    **/
    _count?: true | TopsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopsMaxAggregateInputType
  }

  export type GetTopsAggregateType<T extends TopsAggregateArgs> = {
        [P in keyof T & keyof AggregateTops]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTops[P]>
      : GetScalarType<T[P], AggregateTops[P]>
  }




  export type TopsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TopsWhereInput
    orderBy?: TopsOrderByWithAggregationInput | TopsOrderByWithAggregationInput[]
    by: TopsScalarFieldEnum[] | TopsScalarFieldEnum
    having?: TopsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopsCountAggregateInputType | true
    _avg?: TopsAvgAggregateInputType
    _sum?: TopsSumAggregateInputType
    _min?: TopsMinAggregateInputType
    _max?: TopsMaxAggregateInputType
  }

  export type TopsGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    description: string | null
    url: string
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
    _count: TopsCountAggregateOutputType | null
    _avg: TopsAvgAggregateOutputType | null
    _sum: TopsSumAggregateOutputType | null
    _min: TopsMinAggregateOutputType | null
    _max: TopsMaxAggregateOutputType | null
  }

  type GetTopsGroupByPayload<T extends TopsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopsGroupByOutputType[P]>
            : GetScalarType<T[P], TopsGroupByOutputType[P]>
        }
      >
    >


  export type TopsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tops"]>

  export type TopsSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
  }

  export type TopsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $TopsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Tops"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      user_id: number
      name: string | null
      description: string | null
      url: string
      brand: string | null
      color: string | null
      size: string | null
      occasion: string | null
      material: string | null
    }, ExtArgs["result"]["tops"]>
    composites: {}
  }


  type TopsGetPayload<S extends boolean | null | undefined | TopsDefaultArgs> = $Result.GetResult<Prisma.$TopsPayload, S>

  type TopsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TopsFindManyArgs, 'select' | 'include'> & {
      select?: TopsCountAggregateInputType | true
    }

  export interface TopsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tops'], meta: { name: 'Tops' } }
    /**
     * Find zero or one Tops that matches the filter.
     * @param {TopsFindUniqueArgs} args - Arguments to find a Tops
     * @example
     * // Get one Tops
     * const tops = await prisma.tops.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TopsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TopsFindUniqueArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tops that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TopsFindUniqueOrThrowArgs} args - Arguments to find a Tops
     * @example
     * // Get one Tops
     * const tops = await prisma.tops.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TopsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsFindFirstArgs} args - Arguments to find a Tops
     * @example
     * // Get one Tops
     * const tops = await prisma.tops.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TopsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsFindFirstArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tops that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsFindFirstOrThrowArgs} args - Arguments to find a Tops
     * @example
     * // Get one Tops
     * const tops = await prisma.tops.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TopsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tops
     * const tops = await prisma.tops.findMany()
     * 
     * // Get first 10 Tops
     * const tops = await prisma.tops.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topsWithIdOnly = await prisma.tops.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TopsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tops.
     * @param {TopsCreateArgs} args - Arguments to create a Tops.
     * @example
     * // Create one Tops
     * const Tops = await prisma.tops.create({
     *   data: {
     *     // ... data to create a Tops
     *   }
     * })
     * 
    **/
    create<T extends TopsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TopsCreateArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tops.
     *     @param {TopsCreateManyArgs} args - Arguments to create many Tops.
     *     @example
     *     // Create many Tops
     *     const tops = await prisma.tops.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TopsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tops.
     * @param {TopsDeleteArgs} args - Arguments to delete one Tops.
     * @example
     * // Delete one Tops
     * const Tops = await prisma.tops.delete({
     *   where: {
     *     // ... filter to delete one Tops
     *   }
     * })
     * 
    **/
    delete<T extends TopsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TopsDeleteArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tops.
     * @param {TopsUpdateArgs} args - Arguments to update one Tops.
     * @example
     * // Update one Tops
     * const tops = await prisma.tops.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TopsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TopsUpdateArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tops.
     * @param {TopsDeleteManyArgs} args - Arguments to filter Tops to delete.
     * @example
     * // Delete a few Tops
     * const { count } = await prisma.tops.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TopsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TopsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tops
     * const tops = await prisma.tops.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TopsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TopsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tops.
     * @param {TopsUpsertArgs} args - Arguments to update or create a Tops.
     * @example
     * // Update or create a Tops
     * const tops = await prisma.tops.upsert({
     *   create: {
     *     // ... data to create a Tops
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tops we want to update
     *   }
     * })
    **/
    upsert<T extends TopsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TopsUpsertArgs<ExtArgs>>
    ): Prisma__TopsClient<$Result.GetResult<Prisma.$TopsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsCountArgs} args - Arguments to filter Tops to count.
     * @example
     * // Count the number of Tops
     * const count = await prisma.tops.count({
     *   where: {
     *     // ... the filter for the Tops we want to count
     *   }
     * })
    **/
    count<T extends TopsCountArgs>(
      args?: Subset<T, TopsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopsAggregateArgs>(args: Subset<T, TopsAggregateArgs>): Prisma.PrismaPromise<GetTopsAggregateType<T>>

    /**
     * Group by Tops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopsGroupByArgs['orderBy'] }
        : { orderBy?: TopsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tops model
   */
  readonly fields: TopsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tops.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tops model
   */ 
  interface TopsFieldRefs {
    readonly id: FieldRef<"Tops", 'Int'>
    readonly user_id: FieldRef<"Tops", 'Int'>
    readonly name: FieldRef<"Tops", 'String'>
    readonly description: FieldRef<"Tops", 'String'>
    readonly url: FieldRef<"Tops", 'String'>
    readonly brand: FieldRef<"Tops", 'String'>
    readonly color: FieldRef<"Tops", 'String'>
    readonly size: FieldRef<"Tops", 'String'>
    readonly occasion: FieldRef<"Tops", 'String'>
    readonly material: FieldRef<"Tops", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tops findUnique
   */
  export type TopsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter, which Tops to fetch.
     */
    where: TopsWhereUniqueInput
  }


  /**
   * Tops findUniqueOrThrow
   */
  export type TopsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter, which Tops to fetch.
     */
    where: TopsWhereUniqueInput
  }


  /**
   * Tops findFirst
   */
  export type TopsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter, which Tops to fetch.
     */
    where?: TopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tops to fetch.
     */
    orderBy?: TopsOrderByWithRelationInput | TopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tops.
     */
    cursor?: TopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tops.
     */
    distinct?: TopsScalarFieldEnum | TopsScalarFieldEnum[]
  }


  /**
   * Tops findFirstOrThrow
   */
  export type TopsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter, which Tops to fetch.
     */
    where?: TopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tops to fetch.
     */
    orderBy?: TopsOrderByWithRelationInput | TopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tops.
     */
    cursor?: TopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tops.
     */
    distinct?: TopsScalarFieldEnum | TopsScalarFieldEnum[]
  }


  /**
   * Tops findMany
   */
  export type TopsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter, which Tops to fetch.
     */
    where?: TopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tops to fetch.
     */
    orderBy?: TopsOrderByWithRelationInput | TopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tops.
     */
    cursor?: TopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tops.
     */
    skip?: number
    distinct?: TopsScalarFieldEnum | TopsScalarFieldEnum[]
  }


  /**
   * Tops create
   */
  export type TopsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tops.
     */
    data: XOR<TopsCreateInput, TopsUncheckedCreateInput>
  }


  /**
   * Tops createMany
   */
  export type TopsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tops.
     */
    data: TopsCreateManyInput | TopsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tops update
   */
  export type TopsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tops.
     */
    data: XOR<TopsUpdateInput, TopsUncheckedUpdateInput>
    /**
     * Choose, which Tops to update.
     */
    where: TopsWhereUniqueInput
  }


  /**
   * Tops updateMany
   */
  export type TopsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tops.
     */
    data: XOR<TopsUpdateManyMutationInput, TopsUncheckedUpdateManyInput>
    /**
     * Filter which Tops to update
     */
    where?: TopsWhereInput
  }


  /**
   * Tops upsert
   */
  export type TopsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tops to update in case it exists.
     */
    where: TopsWhereUniqueInput
    /**
     * In case the Tops found by the `where` argument doesn't exist, create a new Tops with this data.
     */
    create: XOR<TopsCreateInput, TopsUncheckedCreateInput>
    /**
     * In case the Tops was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopsUpdateInput, TopsUncheckedUpdateInput>
  }


  /**
   * Tops delete
   */
  export type TopsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
    /**
     * Filter which Tops to delete.
     */
    where: TopsWhereUniqueInput
  }


  /**
   * Tops deleteMany
   */
  export type TopsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tops to delete
     */
    where?: TopsWhereInput
  }


  /**
   * Tops without action
   */
  export type TopsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tops
     */
    select?: TopsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TopsInclude<ExtArgs> | null
  }



  /**
   * Model Bottoms
   */

  export type AggregateBottoms = {
    _count: BottomsCountAggregateOutputType | null
    _avg: BottomsAvgAggregateOutputType | null
    _sum: BottomsSumAggregateOutputType | null
    _min: BottomsMinAggregateOutputType | null
    _max: BottomsMaxAggregateOutputType | null
  }

  export type BottomsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type BottomsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type BottomsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type BottomsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type BottomsCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    url: number
    brand: number
    color: number
    size: number
    occasion: number
    material: number
    _all: number
  }


  export type BottomsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type BottomsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type BottomsMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type BottomsMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type BottomsCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
    _all?: true
  }

  export type BottomsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bottoms to aggregate.
     */
    where?: BottomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bottoms to fetch.
     */
    orderBy?: BottomsOrderByWithRelationInput | BottomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BottomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bottoms
    **/
    _count?: true | BottomsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BottomsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BottomsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BottomsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BottomsMaxAggregateInputType
  }

  export type GetBottomsAggregateType<T extends BottomsAggregateArgs> = {
        [P in keyof T & keyof AggregateBottoms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBottoms[P]>
      : GetScalarType<T[P], AggregateBottoms[P]>
  }




  export type BottomsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BottomsWhereInput
    orderBy?: BottomsOrderByWithAggregationInput | BottomsOrderByWithAggregationInput[]
    by: BottomsScalarFieldEnum[] | BottomsScalarFieldEnum
    having?: BottomsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BottomsCountAggregateInputType | true
    _avg?: BottomsAvgAggregateInputType
    _sum?: BottomsSumAggregateInputType
    _min?: BottomsMinAggregateInputType
    _max?: BottomsMaxAggregateInputType
  }

  export type BottomsGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    description: string | null
    url: string
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
    _count: BottomsCountAggregateOutputType | null
    _avg: BottomsAvgAggregateOutputType | null
    _sum: BottomsSumAggregateOutputType | null
    _min: BottomsMinAggregateOutputType | null
    _max: BottomsMaxAggregateOutputType | null
  }

  type GetBottomsGroupByPayload<T extends BottomsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BottomsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BottomsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BottomsGroupByOutputType[P]>
            : GetScalarType<T[P], BottomsGroupByOutputType[P]>
        }
      >
    >


  export type BottomsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bottoms"]>

  export type BottomsSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
  }

  export type BottomsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $BottomsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Bottoms"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      user_id: number
      name: string | null
      description: string | null
      url: string
      brand: string | null
      color: string | null
      size: string | null
      occasion: string | null
      material: string | null
    }, ExtArgs["result"]["bottoms"]>
    composites: {}
  }


  type BottomsGetPayload<S extends boolean | null | undefined | BottomsDefaultArgs> = $Result.GetResult<Prisma.$BottomsPayload, S>

  type BottomsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BottomsFindManyArgs, 'select' | 'include'> & {
      select?: BottomsCountAggregateInputType | true
    }

  export interface BottomsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bottoms'], meta: { name: 'Bottoms' } }
    /**
     * Find zero or one Bottoms that matches the filter.
     * @param {BottomsFindUniqueArgs} args - Arguments to find a Bottoms
     * @example
     * // Get one Bottoms
     * const bottoms = await prisma.bottoms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BottomsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsFindUniqueArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bottoms that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BottomsFindUniqueOrThrowArgs} args - Arguments to find a Bottoms
     * @example
     * // Get one Bottoms
     * const bottoms = await prisma.bottoms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BottomsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bottoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsFindFirstArgs} args - Arguments to find a Bottoms
     * @example
     * // Get one Bottoms
     * const bottoms = await prisma.bottoms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BottomsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsFindFirstArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bottoms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsFindFirstOrThrowArgs} args - Arguments to find a Bottoms
     * @example
     * // Get one Bottoms
     * const bottoms = await prisma.bottoms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BottomsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bottoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bottoms
     * const bottoms = await prisma.bottoms.findMany()
     * 
     * // Get first 10 Bottoms
     * const bottoms = await prisma.bottoms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bottomsWithIdOnly = await prisma.bottoms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BottomsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bottoms.
     * @param {BottomsCreateArgs} args - Arguments to create a Bottoms.
     * @example
     * // Create one Bottoms
     * const Bottoms = await prisma.bottoms.create({
     *   data: {
     *     // ... data to create a Bottoms
     *   }
     * })
     * 
    **/
    create<T extends BottomsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsCreateArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bottoms.
     *     @param {BottomsCreateManyArgs} args - Arguments to create many Bottoms.
     *     @example
     *     // Create many Bottoms
     *     const bottoms = await prisma.bottoms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BottomsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bottoms.
     * @param {BottomsDeleteArgs} args - Arguments to delete one Bottoms.
     * @example
     * // Delete one Bottoms
     * const Bottoms = await prisma.bottoms.delete({
     *   where: {
     *     // ... filter to delete one Bottoms
     *   }
     * })
     * 
    **/
    delete<T extends BottomsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsDeleteArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bottoms.
     * @param {BottomsUpdateArgs} args - Arguments to update one Bottoms.
     * @example
     * // Update one Bottoms
     * const bottoms = await prisma.bottoms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BottomsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsUpdateArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bottoms.
     * @param {BottomsDeleteManyArgs} args - Arguments to filter Bottoms to delete.
     * @example
     * // Delete a few Bottoms
     * const { count } = await prisma.bottoms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BottomsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BottomsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bottoms
     * const bottoms = await prisma.bottoms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BottomsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bottoms.
     * @param {BottomsUpsertArgs} args - Arguments to update or create a Bottoms.
     * @example
     * // Update or create a Bottoms
     * const bottoms = await prisma.bottoms.upsert({
     *   create: {
     *     // ... data to create a Bottoms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bottoms we want to update
     *   }
     * })
    **/
    upsert<T extends BottomsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BottomsUpsertArgs<ExtArgs>>
    ): Prisma__BottomsClient<$Result.GetResult<Prisma.$BottomsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsCountArgs} args - Arguments to filter Bottoms to count.
     * @example
     * // Count the number of Bottoms
     * const count = await prisma.bottoms.count({
     *   where: {
     *     // ... the filter for the Bottoms we want to count
     *   }
     * })
    **/
    count<T extends BottomsCountArgs>(
      args?: Subset<T, BottomsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BottomsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BottomsAggregateArgs>(args: Subset<T, BottomsAggregateArgs>): Prisma.PrismaPromise<GetBottomsAggregateType<T>>

    /**
     * Group by Bottoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BottomsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BottomsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BottomsGroupByArgs['orderBy'] }
        : { orderBy?: BottomsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BottomsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBottomsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bottoms model
   */
  readonly fields: BottomsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bottoms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BottomsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bottoms model
   */ 
  interface BottomsFieldRefs {
    readonly id: FieldRef<"Bottoms", 'Int'>
    readonly user_id: FieldRef<"Bottoms", 'Int'>
    readonly name: FieldRef<"Bottoms", 'String'>
    readonly description: FieldRef<"Bottoms", 'String'>
    readonly url: FieldRef<"Bottoms", 'String'>
    readonly brand: FieldRef<"Bottoms", 'String'>
    readonly color: FieldRef<"Bottoms", 'String'>
    readonly size: FieldRef<"Bottoms", 'String'>
    readonly occasion: FieldRef<"Bottoms", 'String'>
    readonly material: FieldRef<"Bottoms", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Bottoms findUnique
   */
  export type BottomsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter, which Bottoms to fetch.
     */
    where: BottomsWhereUniqueInput
  }


  /**
   * Bottoms findUniqueOrThrow
   */
  export type BottomsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter, which Bottoms to fetch.
     */
    where: BottomsWhereUniqueInput
  }


  /**
   * Bottoms findFirst
   */
  export type BottomsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter, which Bottoms to fetch.
     */
    where?: BottomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bottoms to fetch.
     */
    orderBy?: BottomsOrderByWithRelationInput | BottomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bottoms.
     */
    cursor?: BottomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bottoms.
     */
    distinct?: BottomsScalarFieldEnum | BottomsScalarFieldEnum[]
  }


  /**
   * Bottoms findFirstOrThrow
   */
  export type BottomsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter, which Bottoms to fetch.
     */
    where?: BottomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bottoms to fetch.
     */
    orderBy?: BottomsOrderByWithRelationInput | BottomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bottoms.
     */
    cursor?: BottomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bottoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bottoms.
     */
    distinct?: BottomsScalarFieldEnum | BottomsScalarFieldEnum[]
  }


  /**
   * Bottoms findMany
   */
  export type BottomsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter, which Bottoms to fetch.
     */
    where?: BottomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bottoms to fetch.
     */
    orderBy?: BottomsOrderByWithRelationInput | BottomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bottoms.
     */
    cursor?: BottomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bottoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bottoms.
     */
    skip?: number
    distinct?: BottomsScalarFieldEnum | BottomsScalarFieldEnum[]
  }


  /**
   * Bottoms create
   */
  export type BottomsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * The data needed to create a Bottoms.
     */
    data: XOR<BottomsCreateInput, BottomsUncheckedCreateInput>
  }


  /**
   * Bottoms createMany
   */
  export type BottomsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bottoms.
     */
    data: BottomsCreateManyInput | BottomsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Bottoms update
   */
  export type BottomsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * The data needed to update a Bottoms.
     */
    data: XOR<BottomsUpdateInput, BottomsUncheckedUpdateInput>
    /**
     * Choose, which Bottoms to update.
     */
    where: BottomsWhereUniqueInput
  }


  /**
   * Bottoms updateMany
   */
  export type BottomsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bottoms.
     */
    data: XOR<BottomsUpdateManyMutationInput, BottomsUncheckedUpdateManyInput>
    /**
     * Filter which Bottoms to update
     */
    where?: BottomsWhereInput
  }


  /**
   * Bottoms upsert
   */
  export type BottomsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * The filter to search for the Bottoms to update in case it exists.
     */
    where: BottomsWhereUniqueInput
    /**
     * In case the Bottoms found by the `where` argument doesn't exist, create a new Bottoms with this data.
     */
    create: XOR<BottomsCreateInput, BottomsUncheckedCreateInput>
    /**
     * In case the Bottoms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BottomsUpdateInput, BottomsUncheckedUpdateInput>
  }


  /**
   * Bottoms delete
   */
  export type BottomsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
    /**
     * Filter which Bottoms to delete.
     */
    where: BottomsWhereUniqueInput
  }


  /**
   * Bottoms deleteMany
   */
  export type BottomsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bottoms to delete
     */
    where?: BottomsWhereInput
  }


  /**
   * Bottoms without action
   */
  export type BottomsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bottoms
     */
    select?: BottomsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BottomsInclude<ExtArgs> | null
  }



  /**
   * Model Shoes
   */

  export type AggregateShoes = {
    _count: ShoesCountAggregateOutputType | null
    _avg: ShoesAvgAggregateOutputType | null
    _sum: ShoesSumAggregateOutputType | null
    _min: ShoesMinAggregateOutputType | null
    _max: ShoesMaxAggregateOutputType | null
  }

  export type ShoesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ShoesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type ShoesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type ShoesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type ShoesCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    url: number
    brand: number
    color: number
    size: number
    occasion: number
    material: number
    _all: number
  }


  export type ShoesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ShoesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type ShoesMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type ShoesMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type ShoesCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
    _all?: true
  }

  export type ShoesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shoes to aggregate.
     */
    where?: ShoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoes to fetch.
     */
    orderBy?: ShoesOrderByWithRelationInput | ShoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shoes
    **/
    _count?: true | ShoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoesMaxAggregateInputType
  }

  export type GetShoesAggregateType<T extends ShoesAggregateArgs> = {
        [P in keyof T & keyof AggregateShoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoes[P]>
      : GetScalarType<T[P], AggregateShoes[P]>
  }




  export type ShoesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ShoesWhereInput
    orderBy?: ShoesOrderByWithAggregationInput | ShoesOrderByWithAggregationInput[]
    by: ShoesScalarFieldEnum[] | ShoesScalarFieldEnum
    having?: ShoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoesCountAggregateInputType | true
    _avg?: ShoesAvgAggregateInputType
    _sum?: ShoesSumAggregateInputType
    _min?: ShoesMinAggregateInputType
    _max?: ShoesMaxAggregateInputType
  }

  export type ShoesGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    description: string | null
    url: string
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
    _count: ShoesCountAggregateOutputType | null
    _avg: ShoesAvgAggregateOutputType | null
    _sum: ShoesSumAggregateOutputType | null
    _min: ShoesMinAggregateOutputType | null
    _max: ShoesMaxAggregateOutputType | null
  }

  type GetShoesGroupByPayload<T extends ShoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoesGroupByOutputType[P]>
            : GetScalarType<T[P], ShoesGroupByOutputType[P]>
        }
      >
    >


  export type ShoesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoes"]>

  export type ShoesSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
  }

  export type ShoesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ShoesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Shoes"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      user_id: number
      name: string | null
      description: string | null
      url: string
      brand: string | null
      color: string | null
      size: string | null
      occasion: string | null
      material: string | null
    }, ExtArgs["result"]["shoes"]>
    composites: {}
  }


  type ShoesGetPayload<S extends boolean | null | undefined | ShoesDefaultArgs> = $Result.GetResult<Prisma.$ShoesPayload, S>

  type ShoesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ShoesFindManyArgs, 'select' | 'include'> & {
      select?: ShoesCountAggregateInputType | true
    }

  export interface ShoesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shoes'], meta: { name: 'Shoes' } }
    /**
     * Find zero or one Shoes that matches the filter.
     * @param {ShoesFindUniqueArgs} args - Arguments to find a Shoes
     * @example
     * // Get one Shoes
     * const shoes = await prisma.shoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesFindUniqueArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Shoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShoesFindUniqueOrThrowArgs} args - Arguments to find a Shoes
     * @example
     * // Get one Shoes
     * const shoes = await prisma.shoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Shoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesFindFirstArgs} args - Arguments to find a Shoes
     * @example
     * // Get one Shoes
     * const shoes = await prisma.shoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesFindFirstArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Shoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesFindFirstOrThrowArgs} args - Arguments to find a Shoes
     * @example
     * // Get one Shoes
     * const shoes = await prisma.shoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Shoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shoes
     * const shoes = await prisma.shoes.findMany()
     * 
     * // Get first 10 Shoes
     * const shoes = await prisma.shoes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoesWithIdOnly = await prisma.shoes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Shoes.
     * @param {ShoesCreateArgs} args - Arguments to create a Shoes.
     * @example
     * // Create one Shoes
     * const Shoes = await prisma.shoes.create({
     *   data: {
     *     // ... data to create a Shoes
     *   }
     * })
     * 
    **/
    create<T extends ShoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesCreateArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Shoes.
     *     @param {ShoesCreateManyArgs} args - Arguments to create many Shoes.
     *     @example
     *     // Create many Shoes
     *     const shoes = await prisma.shoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shoes.
     * @param {ShoesDeleteArgs} args - Arguments to delete one Shoes.
     * @example
     * // Delete one Shoes
     * const Shoes = await prisma.shoes.delete({
     *   where: {
     *     // ... filter to delete one Shoes
     *   }
     * })
     * 
    **/
    delete<T extends ShoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesDeleteArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Shoes.
     * @param {ShoesUpdateArgs} args - Arguments to update one Shoes.
     * @example
     * // Update one Shoes
     * const shoes = await prisma.shoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesUpdateArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Shoes.
     * @param {ShoesDeleteManyArgs} args - Arguments to filter Shoes to delete.
     * @example
     * // Delete a few Shoes
     * const { count } = await prisma.shoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shoes
     * const shoes = await prisma.shoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shoes.
     * @param {ShoesUpsertArgs} args - Arguments to update or create a Shoes.
     * @example
     * // Update or create a Shoes
     * const shoes = await prisma.shoes.upsert({
     *   create: {
     *     // ... data to create a Shoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shoes we want to update
     *   }
     * })
    **/
    upsert<T extends ShoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShoesUpsertArgs<ExtArgs>>
    ): Prisma__ShoesClient<$Result.GetResult<Prisma.$ShoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Shoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesCountArgs} args - Arguments to filter Shoes to count.
     * @example
     * // Count the number of Shoes
     * const count = await prisma.shoes.count({
     *   where: {
     *     // ... the filter for the Shoes we want to count
     *   }
     * })
    **/
    count<T extends ShoesCountArgs>(
      args?: Subset<T, ShoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoesAggregateArgs>(args: Subset<T, ShoesAggregateArgs>): Prisma.PrismaPromise<GetShoesAggregateType<T>>

    /**
     * Group by Shoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoesGroupByArgs['orderBy'] }
        : { orderBy?: ShoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shoes model
   */
  readonly fields: ShoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShoesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Shoes model
   */ 
  interface ShoesFieldRefs {
    readonly id: FieldRef<"Shoes", 'Int'>
    readonly user_id: FieldRef<"Shoes", 'Int'>
    readonly name: FieldRef<"Shoes", 'String'>
    readonly description: FieldRef<"Shoes", 'String'>
    readonly url: FieldRef<"Shoes", 'String'>
    readonly brand: FieldRef<"Shoes", 'String'>
    readonly color: FieldRef<"Shoes", 'String'>
    readonly size: FieldRef<"Shoes", 'String'>
    readonly occasion: FieldRef<"Shoes", 'String'>
    readonly material: FieldRef<"Shoes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Shoes findUnique
   */
  export type ShoesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter, which Shoes to fetch.
     */
    where: ShoesWhereUniqueInput
  }


  /**
   * Shoes findUniqueOrThrow
   */
  export type ShoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter, which Shoes to fetch.
     */
    where: ShoesWhereUniqueInput
  }


  /**
   * Shoes findFirst
   */
  export type ShoesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter, which Shoes to fetch.
     */
    where?: ShoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoes to fetch.
     */
    orderBy?: ShoesOrderByWithRelationInput | ShoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shoes.
     */
    cursor?: ShoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shoes.
     */
    distinct?: ShoesScalarFieldEnum | ShoesScalarFieldEnum[]
  }


  /**
   * Shoes findFirstOrThrow
   */
  export type ShoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter, which Shoes to fetch.
     */
    where?: ShoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoes to fetch.
     */
    orderBy?: ShoesOrderByWithRelationInput | ShoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shoes.
     */
    cursor?: ShoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shoes.
     */
    distinct?: ShoesScalarFieldEnum | ShoesScalarFieldEnum[]
  }


  /**
   * Shoes findMany
   */
  export type ShoesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter, which Shoes to fetch.
     */
    where?: ShoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shoes to fetch.
     */
    orderBy?: ShoesOrderByWithRelationInput | ShoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shoes.
     */
    cursor?: ShoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shoes.
     */
    skip?: number
    distinct?: ShoesScalarFieldEnum | ShoesScalarFieldEnum[]
  }


  /**
   * Shoes create
   */
  export type ShoesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * The data needed to create a Shoes.
     */
    data: XOR<ShoesCreateInput, ShoesUncheckedCreateInput>
  }


  /**
   * Shoes createMany
   */
  export type ShoesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shoes.
     */
    data: ShoesCreateManyInput | ShoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Shoes update
   */
  export type ShoesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * The data needed to update a Shoes.
     */
    data: XOR<ShoesUpdateInput, ShoesUncheckedUpdateInput>
    /**
     * Choose, which Shoes to update.
     */
    where: ShoesWhereUniqueInput
  }


  /**
   * Shoes updateMany
   */
  export type ShoesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shoes.
     */
    data: XOR<ShoesUpdateManyMutationInput, ShoesUncheckedUpdateManyInput>
    /**
     * Filter which Shoes to update
     */
    where?: ShoesWhereInput
  }


  /**
   * Shoes upsert
   */
  export type ShoesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * The filter to search for the Shoes to update in case it exists.
     */
    where: ShoesWhereUniqueInput
    /**
     * In case the Shoes found by the `where` argument doesn't exist, create a new Shoes with this data.
     */
    create: XOR<ShoesCreateInput, ShoesUncheckedCreateInput>
    /**
     * In case the Shoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoesUpdateInput, ShoesUncheckedUpdateInput>
  }


  /**
   * Shoes delete
   */
  export type ShoesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
    /**
     * Filter which Shoes to delete.
     */
    where: ShoesWhereUniqueInput
  }


  /**
   * Shoes deleteMany
   */
  export type ShoesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shoes to delete
     */
    where?: ShoesWhereInput
  }


  /**
   * Shoes without action
   */
  export type ShoesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shoes
     */
    select?: ShoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoesInclude<ExtArgs> | null
  }



  /**
   * Model Accessories
   */

  export type AggregateAccessories = {
    _count: AccessoriesCountAggregateOutputType | null
    _avg: AccessoriesAvgAggregateOutputType | null
    _sum: AccessoriesSumAggregateOutputType | null
    _min: AccessoriesMinAggregateOutputType | null
    _max: AccessoriesMaxAggregateOutputType | null
  }

  export type AccessoriesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AccessoriesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AccessoriesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type AccessoriesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type AccessoriesCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    url: number
    brand: number
    color: number
    size: number
    occasion: number
    material: number
    _all: number
  }


  export type AccessoriesAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AccessoriesSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AccessoriesMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type AccessoriesMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type AccessoriesCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
    _all?: true
  }

  export type AccessoriesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accessories to aggregate.
     */
    where?: AccessoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoriesOrderByWithRelationInput | AccessoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accessories
    **/
    _count?: true | AccessoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessoriesMaxAggregateInputType
  }

  export type GetAccessoriesAggregateType<T extends AccessoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessories[P]>
      : GetScalarType<T[P], AggregateAccessories[P]>
  }




  export type AccessoriesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccessoriesWhereInput
    orderBy?: AccessoriesOrderByWithAggregationInput | AccessoriesOrderByWithAggregationInput[]
    by: AccessoriesScalarFieldEnum[] | AccessoriesScalarFieldEnum
    having?: AccessoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessoriesCountAggregateInputType | true
    _avg?: AccessoriesAvgAggregateInputType
    _sum?: AccessoriesSumAggregateInputType
    _min?: AccessoriesMinAggregateInputType
    _max?: AccessoriesMaxAggregateInputType
  }

  export type AccessoriesGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    description: string | null
    url: string
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
    _count: AccessoriesCountAggregateOutputType | null
    _avg: AccessoriesAvgAggregateOutputType | null
    _sum: AccessoriesSumAggregateOutputType | null
    _min: AccessoriesMinAggregateOutputType | null
    _max: AccessoriesMaxAggregateOutputType | null
  }

  type GetAccessoriesGroupByPayload<T extends AccessoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessoriesGroupByOutputType[P]>
            : GetScalarType<T[P], AccessoriesGroupByOutputType[P]>
        }
      >
    >


  export type AccessoriesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessories"]>

  export type AccessoriesSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
  }

  export type AccessoriesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccessoriesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Accessories"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      user_id: number
      name: string | null
      description: string | null
      url: string
      brand: string | null
      color: string | null
      size: string | null
      occasion: string | null
      material: string | null
    }, ExtArgs["result"]["accessories"]>
    composites: {}
  }


  type AccessoriesGetPayload<S extends boolean | null | undefined | AccessoriesDefaultArgs> = $Result.GetResult<Prisma.$AccessoriesPayload, S>

  type AccessoriesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccessoriesFindManyArgs, 'select' | 'include'> & {
      select?: AccessoriesCountAggregateInputType | true
    }

  export interface AccessoriesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accessories'], meta: { name: 'Accessories' } }
    /**
     * Find zero or one Accessories that matches the filter.
     * @param {AccessoriesFindUniqueArgs} args - Arguments to find a Accessories
     * @example
     * // Get one Accessories
     * const accessories = await prisma.accessories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccessoriesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesFindUniqueArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Accessories that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccessoriesFindUniqueOrThrowArgs} args - Arguments to find a Accessories
     * @example
     * // Get one Accessories
     * const accessories = await prisma.accessories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccessoriesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Accessories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesFindFirstArgs} args - Arguments to find a Accessories
     * @example
     * // Get one Accessories
     * const accessories = await prisma.accessories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccessoriesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesFindFirstArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Accessories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesFindFirstOrThrowArgs} args - Arguments to find a Accessories
     * @example
     * // Get one Accessories
     * const accessories = await prisma.accessories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccessoriesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accessories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accessories
     * const accessories = await prisma.accessories.findMany()
     * 
     * // Get first 10 Accessories
     * const accessories = await prisma.accessories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessoriesWithIdOnly = await prisma.accessories.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccessoriesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Accessories.
     * @param {AccessoriesCreateArgs} args - Arguments to create a Accessories.
     * @example
     * // Create one Accessories
     * const Accessories = await prisma.accessories.create({
     *   data: {
     *     // ... data to create a Accessories
     *   }
     * })
     * 
    **/
    create<T extends AccessoriesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesCreateArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accessories.
     *     @param {AccessoriesCreateManyArgs} args - Arguments to create many Accessories.
     *     @example
     *     // Create many Accessories
     *     const accessories = await prisma.accessories.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccessoriesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accessories.
     * @param {AccessoriesDeleteArgs} args - Arguments to delete one Accessories.
     * @example
     * // Delete one Accessories
     * const Accessories = await prisma.accessories.delete({
     *   where: {
     *     // ... filter to delete one Accessories
     *   }
     * })
     * 
    **/
    delete<T extends AccessoriesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesDeleteArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Accessories.
     * @param {AccessoriesUpdateArgs} args - Arguments to update one Accessories.
     * @example
     * // Update one Accessories
     * const accessories = await prisma.accessories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccessoriesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesUpdateArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accessories.
     * @param {AccessoriesDeleteManyArgs} args - Arguments to filter Accessories to delete.
     * @example
     * // Delete a few Accessories
     * const { count } = await prisma.accessories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccessoriesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessoriesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accessories
     * const accessories = await prisma.accessories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccessoriesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accessories.
     * @param {AccessoriesUpsertArgs} args - Arguments to update or create a Accessories.
     * @example
     * // Update or create a Accessories
     * const accessories = await prisma.accessories.upsert({
     *   create: {
     *     // ... data to create a Accessories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accessories we want to update
     *   }
     * })
    **/
    upsert<T extends AccessoriesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccessoriesUpsertArgs<ExtArgs>>
    ): Prisma__AccessoriesClient<$Result.GetResult<Prisma.$AccessoriesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesCountArgs} args - Arguments to filter Accessories to count.
     * @example
     * // Count the number of Accessories
     * const count = await prisma.accessories.count({
     *   where: {
     *     // ... the filter for the Accessories we want to count
     *   }
     * })
    **/
    count<T extends AccessoriesCountArgs>(
      args?: Subset<T, AccessoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessoriesAggregateArgs>(args: Subset<T, AccessoriesAggregateArgs>): Prisma.PrismaPromise<GetAccessoriesAggregateType<T>>

    /**
     * Group by Accessories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessoriesGroupByArgs['orderBy'] }
        : { orderBy?: AccessoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accessories model
   */
  readonly fields: AccessoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accessories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessoriesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Accessories model
   */ 
  interface AccessoriesFieldRefs {
    readonly id: FieldRef<"Accessories", 'Int'>
    readonly user_id: FieldRef<"Accessories", 'Int'>
    readonly name: FieldRef<"Accessories", 'String'>
    readonly description: FieldRef<"Accessories", 'String'>
    readonly url: FieldRef<"Accessories", 'String'>
    readonly brand: FieldRef<"Accessories", 'String'>
    readonly color: FieldRef<"Accessories", 'String'>
    readonly size: FieldRef<"Accessories", 'String'>
    readonly occasion: FieldRef<"Accessories", 'String'>
    readonly material: FieldRef<"Accessories", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Accessories findUnique
   */
  export type AccessoriesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where: AccessoriesWhereUniqueInput
  }


  /**
   * Accessories findUniqueOrThrow
   */
  export type AccessoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where: AccessoriesWhereUniqueInput
  }


  /**
   * Accessories findFirst
   */
  export type AccessoriesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where?: AccessoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoriesOrderByWithRelationInput | AccessoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accessories.
     */
    cursor?: AccessoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accessories.
     */
    distinct?: AccessoriesScalarFieldEnum | AccessoriesScalarFieldEnum[]
  }


  /**
   * Accessories findFirstOrThrow
   */
  export type AccessoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where?: AccessoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoriesOrderByWithRelationInput | AccessoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accessories.
     */
    cursor?: AccessoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accessories.
     */
    distinct?: AccessoriesScalarFieldEnum | AccessoriesScalarFieldEnum[]
  }


  /**
   * Accessories findMany
   */
  export type AccessoriesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter, which Accessories to fetch.
     */
    where?: AccessoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accessories to fetch.
     */
    orderBy?: AccessoriesOrderByWithRelationInput | AccessoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accessories.
     */
    cursor?: AccessoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accessories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accessories.
     */
    skip?: number
    distinct?: AccessoriesScalarFieldEnum | AccessoriesScalarFieldEnum[]
  }


  /**
   * Accessories create
   */
  export type AccessoriesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Accessories.
     */
    data: XOR<AccessoriesCreateInput, AccessoriesUncheckedCreateInput>
  }


  /**
   * Accessories createMany
   */
  export type AccessoriesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accessories.
     */
    data: AccessoriesCreateManyInput | AccessoriesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Accessories update
   */
  export type AccessoriesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Accessories.
     */
    data: XOR<AccessoriesUpdateInput, AccessoriesUncheckedUpdateInput>
    /**
     * Choose, which Accessories to update.
     */
    where: AccessoriesWhereUniqueInput
  }


  /**
   * Accessories updateMany
   */
  export type AccessoriesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accessories.
     */
    data: XOR<AccessoriesUpdateManyMutationInput, AccessoriesUncheckedUpdateManyInput>
    /**
     * Filter which Accessories to update
     */
    where?: AccessoriesWhereInput
  }


  /**
   * Accessories upsert
   */
  export type AccessoriesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Accessories to update in case it exists.
     */
    where: AccessoriesWhereUniqueInput
    /**
     * In case the Accessories found by the `where` argument doesn't exist, create a new Accessories with this data.
     */
    create: XOR<AccessoriesCreateInput, AccessoriesUncheckedCreateInput>
    /**
     * In case the Accessories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessoriesUpdateInput, AccessoriesUncheckedUpdateInput>
  }


  /**
   * Accessories delete
   */
  export type AccessoriesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
    /**
     * Filter which Accessories to delete.
     */
    where: AccessoriesWhereUniqueInput
  }


  /**
   * Accessories deleteMany
   */
  export type AccessoriesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accessories to delete
     */
    where?: AccessoriesWhereInput
  }


  /**
   * Accessories without action
   */
  export type AccessoriesDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accessories
     */
    select?: AccessoriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccessoriesInclude<ExtArgs> | null
  }



  /**
   * Model Accs
   */

  export type AggregateAccs = {
    _count: AccsCountAggregateOutputType | null
    _avg: AccsAvgAggregateOutputType | null
    _sum: AccsSumAggregateOutputType | null
    _min: AccsMinAggregateOutputType | null
    _max: AccsMaxAggregateOutputType | null
  }

  export type AccsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AccsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AccsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type AccsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    name: string | null
    description: string | null
    url: string | null
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
  }

  export type AccsCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    url: number
    brand: number
    color: number
    size: number
    occasion: number
    material: number
    _all: number
  }


  export type AccsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AccsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AccsMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type AccsMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
  }

  export type AccsCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    url?: true
    brand?: true
    color?: true
    size?: true
    occasion?: true
    material?: true
    _all?: true
  }

  export type AccsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accs to aggregate.
     */
    where?: AccsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accs to fetch.
     */
    orderBy?: AccsOrderByWithRelationInput | AccsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accs
    **/
    _count?: true | AccsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccsMaxAggregateInputType
  }

  export type GetAccsAggregateType<T extends AccsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccs[P]>
      : GetScalarType<T[P], AggregateAccs[P]>
  }




  export type AccsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccsWhereInput
    orderBy?: AccsOrderByWithAggregationInput | AccsOrderByWithAggregationInput[]
    by: AccsScalarFieldEnum[] | AccsScalarFieldEnum
    having?: AccsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccsCountAggregateInputType | true
    _avg?: AccsAvgAggregateInputType
    _sum?: AccsSumAggregateInputType
    _min?: AccsMinAggregateInputType
    _max?: AccsMaxAggregateInputType
  }

  export type AccsGroupByOutputType = {
    id: number
    user_id: number
    name: string | null
    description: string | null
    url: string
    brand: string | null
    color: string | null
    size: string | null
    occasion: string | null
    material: string | null
    _count: AccsCountAggregateOutputType | null
    _avg: AccsAvgAggregateOutputType | null
    _sum: AccsSumAggregateOutputType | null
    _min: AccsMinAggregateOutputType | null
    _max: AccsMaxAggregateOutputType | null
  }

  type GetAccsGroupByPayload<T extends AccsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccsGroupByOutputType[P]>
            : GetScalarType<T[P], AccsGroupByOutputType[P]>
        }
      >
    >


  export type AccsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accs"]>

  export type AccsSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    url?: boolean
    brand?: boolean
    color?: boolean
    size?: boolean
    occasion?: boolean
    material?: boolean
  }

  export type AccsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Accs"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: number
      user_id: number
      name: string | null
      description: string | null
      url: string
      brand: string | null
      color: string | null
      size: string | null
      occasion: string | null
      material: string | null
    }, ExtArgs["result"]["accs"]>
    composites: {}
  }


  type AccsGetPayload<S extends boolean | null | undefined | AccsDefaultArgs> = $Result.GetResult<Prisma.$AccsPayload, S>

  type AccsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccsFindManyArgs, 'select' | 'include'> & {
      select?: AccsCountAggregateInputType | true
    }

  export interface AccsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Accs'], meta: { name: 'Accs' } }
    /**
     * Find zero or one Accs that matches the filter.
     * @param {AccsFindUniqueArgs} args - Arguments to find a Accs
     * @example
     * // Get one Accs
     * const accs = await prisma.accs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccsFindUniqueArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Accs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccsFindUniqueOrThrowArgs} args - Arguments to find a Accs
     * @example
     * // Get one Accs
     * const accs = await prisma.accs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Accs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsFindFirstArgs} args - Arguments to find a Accs
     * @example
     * // Get one Accs
     * const accs = await prisma.accs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsFindFirstArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Accs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsFindFirstOrThrowArgs} args - Arguments to find a Accs
     * @example
     * // Get one Accs
     * const accs = await prisma.accs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accs
     * const accs = await prisma.accs.findMany()
     * 
     * // Get first 10 Accs
     * const accs = await prisma.accs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accsWithIdOnly = await prisma.accs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Accs.
     * @param {AccsCreateArgs} args - Arguments to create a Accs.
     * @example
     * // Create one Accs
     * const Accs = await prisma.accs.create({
     *   data: {
     *     // ... data to create a Accs
     *   }
     * })
     * 
    **/
    create<T extends AccsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccsCreateArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accs.
     *     @param {AccsCreateManyArgs} args - Arguments to create many Accs.
     *     @example
     *     // Create many Accs
     *     const accs = await prisma.accs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accs.
     * @param {AccsDeleteArgs} args - Arguments to delete one Accs.
     * @example
     * // Delete one Accs
     * const Accs = await prisma.accs.delete({
     *   where: {
     *     // ... filter to delete one Accs
     *   }
     * })
     * 
    **/
    delete<T extends AccsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccsDeleteArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Accs.
     * @param {AccsUpdateArgs} args - Arguments to update one Accs.
     * @example
     * // Update one Accs
     * const accs = await prisma.accs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccsUpdateArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accs.
     * @param {AccsDeleteManyArgs} args - Arguments to filter Accs to delete.
     * @example
     * // Delete a few Accs
     * const { count } = await prisma.accs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accs
     * const accs = await prisma.accs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accs.
     * @param {AccsUpsertArgs} args - Arguments to update or create a Accs.
     * @example
     * // Update or create a Accs
     * const accs = await prisma.accs.upsert({
     *   create: {
     *     // ... data to create a Accs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accs we want to update
     *   }
     * })
    **/
    upsert<T extends AccsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccsUpsertArgs<ExtArgs>>
    ): Prisma__AccsClient<$Result.GetResult<Prisma.$AccsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsCountArgs} args - Arguments to filter Accs to count.
     * @example
     * // Count the number of Accs
     * const count = await prisma.accs.count({
     *   where: {
     *     // ... the filter for the Accs we want to count
     *   }
     * })
    **/
    count<T extends AccsCountArgs>(
      args?: Subset<T, AccsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccsAggregateArgs>(args: Subset<T, AccsAggregateArgs>): Prisma.PrismaPromise<GetAccsAggregateType<T>>

    /**
     * Group by Accs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccsGroupByArgs['orderBy'] }
        : { orderBy?: AccsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Accs model
   */
  readonly fields: AccsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Accs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Accs model
   */ 
  interface AccsFieldRefs {
    readonly id: FieldRef<"Accs", 'Int'>
    readonly user_id: FieldRef<"Accs", 'Int'>
    readonly name: FieldRef<"Accs", 'String'>
    readonly description: FieldRef<"Accs", 'String'>
    readonly url: FieldRef<"Accs", 'String'>
    readonly brand: FieldRef<"Accs", 'String'>
    readonly color: FieldRef<"Accs", 'String'>
    readonly size: FieldRef<"Accs", 'String'>
    readonly occasion: FieldRef<"Accs", 'String'>
    readonly material: FieldRef<"Accs", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Accs findUnique
   */
  export type AccsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter, which Accs to fetch.
     */
    where: AccsWhereUniqueInput
  }


  /**
   * Accs findUniqueOrThrow
   */
  export type AccsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter, which Accs to fetch.
     */
    where: AccsWhereUniqueInput
  }


  /**
   * Accs findFirst
   */
  export type AccsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter, which Accs to fetch.
     */
    where?: AccsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accs to fetch.
     */
    orderBy?: AccsOrderByWithRelationInput | AccsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accs.
     */
    cursor?: AccsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accs.
     */
    distinct?: AccsScalarFieldEnum | AccsScalarFieldEnum[]
  }


  /**
   * Accs findFirstOrThrow
   */
  export type AccsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter, which Accs to fetch.
     */
    where?: AccsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accs to fetch.
     */
    orderBy?: AccsOrderByWithRelationInput | AccsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accs.
     */
    cursor?: AccsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accs.
     */
    distinct?: AccsScalarFieldEnum | AccsScalarFieldEnum[]
  }


  /**
   * Accs findMany
   */
  export type AccsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter, which Accs to fetch.
     */
    where?: AccsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accs to fetch.
     */
    orderBy?: AccsOrderByWithRelationInput | AccsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accs.
     */
    cursor?: AccsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accs.
     */
    skip?: number
    distinct?: AccsScalarFieldEnum | AccsScalarFieldEnum[]
  }


  /**
   * Accs create
   */
  export type AccsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * The data needed to create a Accs.
     */
    data: XOR<AccsCreateInput, AccsUncheckedCreateInput>
  }


  /**
   * Accs createMany
   */
  export type AccsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accs.
     */
    data: AccsCreateManyInput | AccsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Accs update
   */
  export type AccsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * The data needed to update a Accs.
     */
    data: XOR<AccsUpdateInput, AccsUncheckedUpdateInput>
    /**
     * Choose, which Accs to update.
     */
    where: AccsWhereUniqueInput
  }


  /**
   * Accs updateMany
   */
  export type AccsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accs.
     */
    data: XOR<AccsUpdateManyMutationInput, AccsUncheckedUpdateManyInput>
    /**
     * Filter which Accs to update
     */
    where?: AccsWhereInput
  }


  /**
   * Accs upsert
   */
  export type AccsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * The filter to search for the Accs to update in case it exists.
     */
    where: AccsWhereUniqueInput
    /**
     * In case the Accs found by the `where` argument doesn't exist, create a new Accs with this data.
     */
    create: XOR<AccsCreateInput, AccsUncheckedCreateInput>
    /**
     * In case the Accs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccsUpdateInput, AccsUncheckedUpdateInput>
  }


  /**
   * Accs delete
   */
  export type AccsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
    /**
     * Filter which Accs to delete.
     */
    where: AccsWhereUniqueInput
  }


  /**
   * Accs deleteMany
   */
  export type AccsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accs to delete
     */
    where?: AccsWhereInput
  }


  /**
   * Accs without action
   */
  export type AccsDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Accs
     */
    select?: AccsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const TopsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    url: 'url',
    brand: 'brand',
    color: 'color',
    size: 'size',
    occasion: 'occasion',
    material: 'material'
  };

  export type TopsScalarFieldEnum = (typeof TopsScalarFieldEnum)[keyof typeof TopsScalarFieldEnum]


  export const BottomsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    url: 'url',
    brand: 'brand',
    color: 'color',
    size: 'size',
    occasion: 'occasion',
    material: 'material'
  };

  export type BottomsScalarFieldEnum = (typeof BottomsScalarFieldEnum)[keyof typeof BottomsScalarFieldEnum]


  export const ShoesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    url: 'url',
    brand: 'brand',
    color: 'color',
    size: 'size',
    occasion: 'occasion',
    material: 'material'
  };

  export type ShoesScalarFieldEnum = (typeof ShoesScalarFieldEnum)[keyof typeof ShoesScalarFieldEnum]


  export const AccessoriesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    url: 'url',
    brand: 'brand',
    color: 'color',
    size: 'size',
    occasion: 'occasion',
    material: 'material'
  };

  export type AccessoriesScalarFieldEnum = (typeof AccessoriesScalarFieldEnum)[keyof typeof AccessoriesScalarFieldEnum]


  export const AccsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    url: 'url',
    brand: 'brand',
    color: 'color',
    size: 'size',
    occasion: 'occasion',
    material: 'material'
  };

  export type AccsScalarFieldEnum = (typeof AccsScalarFieldEnum)[keyof typeof AccsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    tops?: TopsListRelationFilter
    bottoms?: BottomsListRelationFilter
    shoes?: ShoesListRelationFilter
    accessories?: AccessoriesListRelationFilter
    accs?: AccsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    tops?: TopsOrderByRelationAggregateInput
    bottoms?: BottomsOrderByRelationAggregateInput
    shoes?: ShoesOrderByRelationAggregateInput
    accessories?: AccessoriesOrderByRelationAggregateInput
    accs?: AccsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    tops?: TopsListRelationFilter
    bottoms?: BottomsListRelationFilter
    shoes?: ShoesListRelationFilter
    accessories?: AccessoriesListRelationFilter
    accs?: AccsListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type TopsWhereInput = {
    AND?: TopsWhereInput | TopsWhereInput[]
    OR?: TopsWhereInput[]
    NOT?: TopsWhereInput | TopsWhereInput[]
    id?: IntFilter<"Tops"> | number
    user_id?: IntFilter<"Tops"> | number
    name?: StringNullableFilter<"Tops"> | string | null
    description?: StringNullableFilter<"Tops"> | string | null
    url?: StringFilter<"Tops"> | string
    brand?: StringNullableFilter<"Tops"> | string | null
    color?: StringNullableFilter<"Tops"> | string | null
    size?: StringNullableFilter<"Tops"> | string | null
    occasion?: StringNullableFilter<"Tops"> | string | null
    material?: StringNullableFilter<"Tops"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TopsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TopsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: TopsWhereInput | TopsWhereInput[]
    OR?: TopsWhereInput[]
    NOT?: TopsWhereInput | TopsWhereInput[]
    user_id?: IntFilter<"Tops"> | number
    name?: StringNullableFilter<"Tops"> | string | null
    description?: StringNullableFilter<"Tops"> | string | null
    brand?: StringNullableFilter<"Tops"> | string | null
    color?: StringNullableFilter<"Tops"> | string | null
    size?: StringNullableFilter<"Tops"> | string | null
    occasion?: StringNullableFilter<"Tops"> | string | null
    material?: StringNullableFilter<"Tops"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "url">

  export type TopsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    _count?: TopsCountOrderByAggregateInput
    _avg?: TopsAvgOrderByAggregateInput
    _max?: TopsMaxOrderByAggregateInput
    _min?: TopsMinOrderByAggregateInput
    _sum?: TopsSumOrderByAggregateInput
  }

  export type TopsScalarWhereWithAggregatesInput = {
    AND?: TopsScalarWhereWithAggregatesInput | TopsScalarWhereWithAggregatesInput[]
    OR?: TopsScalarWhereWithAggregatesInput[]
    NOT?: TopsScalarWhereWithAggregatesInput | TopsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tops"> | number
    user_id?: IntWithAggregatesFilter<"Tops"> | number
    name?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    description?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    url?: StringWithAggregatesFilter<"Tops"> | string
    brand?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    color?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    size?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    occasion?: StringNullableWithAggregatesFilter<"Tops"> | string | null
    material?: StringNullableWithAggregatesFilter<"Tops"> | string | null
  }

  export type BottomsWhereInput = {
    AND?: BottomsWhereInput | BottomsWhereInput[]
    OR?: BottomsWhereInput[]
    NOT?: BottomsWhereInput | BottomsWhereInput[]
    id?: IntFilter<"Bottoms"> | number
    user_id?: IntFilter<"Bottoms"> | number
    name?: StringNullableFilter<"Bottoms"> | string | null
    description?: StringNullableFilter<"Bottoms"> | string | null
    url?: StringFilter<"Bottoms"> | string
    brand?: StringNullableFilter<"Bottoms"> | string | null
    color?: StringNullableFilter<"Bottoms"> | string | null
    size?: StringNullableFilter<"Bottoms"> | string | null
    occasion?: StringNullableFilter<"Bottoms"> | string | null
    material?: StringNullableFilter<"Bottoms"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BottomsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BottomsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: BottomsWhereInput | BottomsWhereInput[]
    OR?: BottomsWhereInput[]
    NOT?: BottomsWhereInput | BottomsWhereInput[]
    user_id?: IntFilter<"Bottoms"> | number
    name?: StringNullableFilter<"Bottoms"> | string | null
    description?: StringNullableFilter<"Bottoms"> | string | null
    brand?: StringNullableFilter<"Bottoms"> | string | null
    color?: StringNullableFilter<"Bottoms"> | string | null
    size?: StringNullableFilter<"Bottoms"> | string | null
    occasion?: StringNullableFilter<"Bottoms"> | string | null
    material?: StringNullableFilter<"Bottoms"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "url">

  export type BottomsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    _count?: BottomsCountOrderByAggregateInput
    _avg?: BottomsAvgOrderByAggregateInput
    _max?: BottomsMaxOrderByAggregateInput
    _min?: BottomsMinOrderByAggregateInput
    _sum?: BottomsSumOrderByAggregateInput
  }

  export type BottomsScalarWhereWithAggregatesInput = {
    AND?: BottomsScalarWhereWithAggregatesInput | BottomsScalarWhereWithAggregatesInput[]
    OR?: BottomsScalarWhereWithAggregatesInput[]
    NOT?: BottomsScalarWhereWithAggregatesInput | BottomsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bottoms"> | number
    user_id?: IntWithAggregatesFilter<"Bottoms"> | number
    name?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    description?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    url?: StringWithAggregatesFilter<"Bottoms"> | string
    brand?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    color?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    size?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    occasion?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
    material?: StringNullableWithAggregatesFilter<"Bottoms"> | string | null
  }

  export type ShoesWhereInput = {
    AND?: ShoesWhereInput | ShoesWhereInput[]
    OR?: ShoesWhereInput[]
    NOT?: ShoesWhereInput | ShoesWhereInput[]
    id?: IntFilter<"Shoes"> | number
    user_id?: IntFilter<"Shoes"> | number
    name?: StringNullableFilter<"Shoes"> | string | null
    description?: StringNullableFilter<"Shoes"> | string | null
    url?: StringFilter<"Shoes"> | string
    brand?: StringNullableFilter<"Shoes"> | string | null
    color?: StringNullableFilter<"Shoes"> | string | null
    size?: StringNullableFilter<"Shoes"> | string | null
    occasion?: StringNullableFilter<"Shoes"> | string | null
    material?: StringNullableFilter<"Shoes"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ShoesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ShoesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: ShoesWhereInput | ShoesWhereInput[]
    OR?: ShoesWhereInput[]
    NOT?: ShoesWhereInput | ShoesWhereInput[]
    user_id?: IntFilter<"Shoes"> | number
    name?: StringNullableFilter<"Shoes"> | string | null
    description?: StringNullableFilter<"Shoes"> | string | null
    brand?: StringNullableFilter<"Shoes"> | string | null
    color?: StringNullableFilter<"Shoes"> | string | null
    size?: StringNullableFilter<"Shoes"> | string | null
    occasion?: StringNullableFilter<"Shoes"> | string | null
    material?: StringNullableFilter<"Shoes"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "url">

  export type ShoesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    _count?: ShoesCountOrderByAggregateInput
    _avg?: ShoesAvgOrderByAggregateInput
    _max?: ShoesMaxOrderByAggregateInput
    _min?: ShoesMinOrderByAggregateInput
    _sum?: ShoesSumOrderByAggregateInput
  }

  export type ShoesScalarWhereWithAggregatesInput = {
    AND?: ShoesScalarWhereWithAggregatesInput | ShoesScalarWhereWithAggregatesInput[]
    OR?: ShoesScalarWhereWithAggregatesInput[]
    NOT?: ShoesScalarWhereWithAggregatesInput | ShoesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shoes"> | number
    user_id?: IntWithAggregatesFilter<"Shoes"> | number
    name?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    description?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    url?: StringWithAggregatesFilter<"Shoes"> | string
    brand?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    color?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    size?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    occasion?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
    material?: StringNullableWithAggregatesFilter<"Shoes"> | string | null
  }

  export type AccessoriesWhereInput = {
    AND?: AccessoriesWhereInput | AccessoriesWhereInput[]
    OR?: AccessoriesWhereInput[]
    NOT?: AccessoriesWhereInput | AccessoriesWhereInput[]
    id?: IntFilter<"Accessories"> | number
    user_id?: IntFilter<"Accessories"> | number
    name?: StringNullableFilter<"Accessories"> | string | null
    description?: StringNullableFilter<"Accessories"> | string | null
    url?: StringFilter<"Accessories"> | string
    brand?: StringNullableFilter<"Accessories"> | string | null
    color?: StringNullableFilter<"Accessories"> | string | null
    size?: StringNullableFilter<"Accessories"> | string | null
    occasion?: StringNullableFilter<"Accessories"> | string | null
    material?: StringNullableFilter<"Accessories"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccessoriesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccessoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: AccessoriesWhereInput | AccessoriesWhereInput[]
    OR?: AccessoriesWhereInput[]
    NOT?: AccessoriesWhereInput | AccessoriesWhereInput[]
    user_id?: IntFilter<"Accessories"> | number
    name?: StringNullableFilter<"Accessories"> | string | null
    description?: StringNullableFilter<"Accessories"> | string | null
    brand?: StringNullableFilter<"Accessories"> | string | null
    color?: StringNullableFilter<"Accessories"> | string | null
    size?: StringNullableFilter<"Accessories"> | string | null
    occasion?: StringNullableFilter<"Accessories"> | string | null
    material?: StringNullableFilter<"Accessories"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "url">

  export type AccessoriesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    _count?: AccessoriesCountOrderByAggregateInput
    _avg?: AccessoriesAvgOrderByAggregateInput
    _max?: AccessoriesMaxOrderByAggregateInput
    _min?: AccessoriesMinOrderByAggregateInput
    _sum?: AccessoriesSumOrderByAggregateInput
  }

  export type AccessoriesScalarWhereWithAggregatesInput = {
    AND?: AccessoriesScalarWhereWithAggregatesInput | AccessoriesScalarWhereWithAggregatesInput[]
    OR?: AccessoriesScalarWhereWithAggregatesInput[]
    NOT?: AccessoriesScalarWhereWithAggregatesInput | AccessoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Accessories"> | number
    user_id?: IntWithAggregatesFilter<"Accessories"> | number
    name?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    description?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    url?: StringWithAggregatesFilter<"Accessories"> | string
    brand?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    color?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    size?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    occasion?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
    material?: StringNullableWithAggregatesFilter<"Accessories"> | string | null
  }

  export type AccsWhereInput = {
    AND?: AccsWhereInput | AccsWhereInput[]
    OR?: AccsWhereInput[]
    NOT?: AccsWhereInput | AccsWhereInput[]
    id?: IntFilter<"Accs"> | number
    user_id?: IntFilter<"Accs"> | number
    name?: StringNullableFilter<"Accs"> | string | null
    description?: StringNullableFilter<"Accs"> | string | null
    url?: StringFilter<"Accs"> | string
    brand?: StringNullableFilter<"Accs"> | string | null
    color?: StringNullableFilter<"Accs"> | string | null
    size?: StringNullableFilter<"Accs"> | string | null
    occasion?: StringNullableFilter<"Accs"> | string | null
    material?: StringNullableFilter<"Accs"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: AccsWhereInput | AccsWhereInput[]
    OR?: AccsWhereInput[]
    NOT?: AccsWhereInput | AccsWhereInput[]
    user_id?: IntFilter<"Accs"> | number
    name?: StringNullableFilter<"Accs"> | string | null
    description?: StringNullableFilter<"Accs"> | string | null
    brand?: StringNullableFilter<"Accs"> | string | null
    color?: StringNullableFilter<"Accs"> | string | null
    size?: StringNullableFilter<"Accs"> | string | null
    occasion?: StringNullableFilter<"Accs"> | string | null
    material?: StringNullableFilter<"Accs"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "url">

  export type AccsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    brand?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    occasion?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    _count?: AccsCountOrderByAggregateInput
    _avg?: AccsAvgOrderByAggregateInput
    _max?: AccsMaxOrderByAggregateInput
    _min?: AccsMinOrderByAggregateInput
    _sum?: AccsSumOrderByAggregateInput
  }

  export type AccsScalarWhereWithAggregatesInput = {
    AND?: AccsScalarWhereWithAggregatesInput | AccsScalarWhereWithAggregatesInput[]
    OR?: AccsScalarWhereWithAggregatesInput[]
    NOT?: AccsScalarWhereWithAggregatesInput | AccsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Accs"> | number
    user_id?: IntWithAggregatesFilter<"Accs"> | number
    name?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    description?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    url?: StringWithAggregatesFilter<"Accs"> | string
    brand?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    color?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    size?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    occasion?: StringNullableWithAggregatesFilter<"Accs"> | string | null
    material?: StringNullableWithAggregatesFilter<"Accs"> | string | null
  }

  export type UserCreateInput = {
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsCreateNestedManyWithoutUserInput
    bottoms?: BottomsCreateNestedManyWithoutUserInput
    shoes?: ShoesCreateNestedManyWithoutUserInput
    accessories?: AccessoriesCreateNestedManyWithoutUserInput
    accs?: AccsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsUncheckedCreateNestedManyWithoutUserInput
    bottoms?: BottomsUncheckedCreateNestedManyWithoutUserInput
    shoes?: ShoesUncheckedCreateNestedManyWithoutUserInput
    accessories?: AccessoriesUncheckedCreateNestedManyWithoutUserInput
    accs?: AccsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUpdateManyWithoutUserNestedInput
    shoes?: ShoesUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUpdateManyWithoutUserNestedInput
    accs?: AccsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUncheckedUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUncheckedUpdateManyWithoutUserNestedInput
    shoes?: ShoesUncheckedUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUncheckedUpdateManyWithoutUserNestedInput
    accs?: AccsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopsCreateInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
    user: UserCreateNestedOneWithoutTopsInput
  }

  export type TopsUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type TopsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTopsNestedInput
  }

  export type TopsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopsCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type TopsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsCreateInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
    user: UserCreateNestedOneWithoutBottomsInput
  }

  export type BottomsUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type BottomsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBottomsNestedInput
  }

  export type BottomsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type BottomsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesCreateInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
    user: UserCreateNestedOneWithoutShoesInput
  }

  export type ShoesUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type ShoesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutShoesNestedInput
  }

  export type ShoesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type ShoesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesCreateInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
    user: UserCreateNestedOneWithoutAccessoriesInput
  }

  export type AccessoriesUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccessoriesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccessoriesNestedInput
  }

  export type AccessoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccessoriesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsCreateInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
    user: UserCreateNestedOneWithoutAccsInput
  }

  export type AccsUncheckedCreateInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccsNestedInput
  }

  export type AccsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsCreateManyInput = {
    id?: number
    user_id: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type TopsListRelationFilter = {
    every?: TopsWhereInput
    some?: TopsWhereInput
    none?: TopsWhereInput
  }

  export type BottomsListRelationFilter = {
    every?: BottomsWhereInput
    some?: BottomsWhereInput
    none?: BottomsWhereInput
  }

  export type ShoesListRelationFilter = {
    every?: ShoesWhereInput
    some?: ShoesWhereInput
    none?: ShoesWhereInput
  }

  export type AccessoriesListRelationFilter = {
    every?: AccessoriesWhereInput
    some?: AccessoriesWhereInput
    none?: AccessoriesWhereInput
  }

  export type AccsListRelationFilter = {
    every?: AccsWhereInput
    some?: AccsWhereInput
    none?: AccsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TopsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BottomsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TopsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type TopsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type TopsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type TopsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type TopsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BottomsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type BottomsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BottomsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type BottomsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type BottomsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ShoesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type ShoesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ShoesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type ShoesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type ShoesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AccessoriesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccessoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AccessoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccessoriesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccessoriesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AccsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AccsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    url?: SortOrder
    brand?: SortOrder
    color?: SortOrder
    size?: SortOrder
    occasion?: SortOrder
    material?: SortOrder
  }

  export type AccsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type TopsCreateNestedManyWithoutUserInput = {
    create?: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput> | TopsCreateWithoutUserInput[] | TopsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopsCreateOrConnectWithoutUserInput | TopsCreateOrConnectWithoutUserInput[]
    createMany?: TopsCreateManyUserInputEnvelope
    connect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
  }

  export type BottomsCreateNestedManyWithoutUserInput = {
    create?: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput> | BottomsCreateWithoutUserInput[] | BottomsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BottomsCreateOrConnectWithoutUserInput | BottomsCreateOrConnectWithoutUserInput[]
    createMany?: BottomsCreateManyUserInputEnvelope
    connect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
  }

  export type ShoesCreateNestedManyWithoutUserInput = {
    create?: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput> | ShoesCreateWithoutUserInput[] | ShoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoesCreateOrConnectWithoutUserInput | ShoesCreateOrConnectWithoutUserInput[]
    createMany?: ShoesCreateManyUserInputEnvelope
    connect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
  }

  export type AccessoriesCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput> | AccessoriesCreateWithoutUserInput[] | AccessoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessoriesCreateOrConnectWithoutUserInput | AccessoriesCreateOrConnectWithoutUserInput[]
    createMany?: AccessoriesCreateManyUserInputEnvelope
    connect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
  }

  export type AccsCreateNestedManyWithoutUserInput = {
    create?: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput> | AccsCreateWithoutUserInput[] | AccsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccsCreateOrConnectWithoutUserInput | AccsCreateOrConnectWithoutUserInput[]
    createMany?: AccsCreateManyUserInputEnvelope
    connect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
  }

  export type TopsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput> | TopsCreateWithoutUserInput[] | TopsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopsCreateOrConnectWithoutUserInput | TopsCreateOrConnectWithoutUserInput[]
    createMany?: TopsCreateManyUserInputEnvelope
    connect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
  }

  export type BottomsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput> | BottomsCreateWithoutUserInput[] | BottomsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BottomsCreateOrConnectWithoutUserInput | BottomsCreateOrConnectWithoutUserInput[]
    createMany?: BottomsCreateManyUserInputEnvelope
    connect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
  }

  export type ShoesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput> | ShoesCreateWithoutUserInput[] | ShoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoesCreateOrConnectWithoutUserInput | ShoesCreateOrConnectWithoutUserInput[]
    createMany?: ShoesCreateManyUserInputEnvelope
    connect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
  }

  export type AccessoriesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput> | AccessoriesCreateWithoutUserInput[] | AccessoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessoriesCreateOrConnectWithoutUserInput | AccessoriesCreateOrConnectWithoutUserInput[]
    createMany?: AccessoriesCreateManyUserInputEnvelope
    connect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
  }

  export type AccsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput> | AccsCreateWithoutUserInput[] | AccsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccsCreateOrConnectWithoutUserInput | AccsCreateOrConnectWithoutUserInput[]
    createMany?: AccsCreateManyUserInputEnvelope
    connect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type TopsUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput> | TopsCreateWithoutUserInput[] | TopsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopsCreateOrConnectWithoutUserInput | TopsCreateOrConnectWithoutUserInput[]
    upsert?: TopsUpsertWithWhereUniqueWithoutUserInput | TopsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopsCreateManyUserInputEnvelope
    set?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    disconnect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    delete?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    connect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    update?: TopsUpdateWithWhereUniqueWithoutUserInput | TopsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopsUpdateManyWithWhereWithoutUserInput | TopsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopsScalarWhereInput | TopsScalarWhereInput[]
  }

  export type BottomsUpdateManyWithoutUserNestedInput = {
    create?: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput> | BottomsCreateWithoutUserInput[] | BottomsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BottomsCreateOrConnectWithoutUserInput | BottomsCreateOrConnectWithoutUserInput[]
    upsert?: BottomsUpsertWithWhereUniqueWithoutUserInput | BottomsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BottomsCreateManyUserInputEnvelope
    set?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    disconnect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    delete?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    connect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    update?: BottomsUpdateWithWhereUniqueWithoutUserInput | BottomsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BottomsUpdateManyWithWhereWithoutUserInput | BottomsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BottomsScalarWhereInput | BottomsScalarWhereInput[]
  }

  export type ShoesUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput> | ShoesCreateWithoutUserInput[] | ShoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoesCreateOrConnectWithoutUserInput | ShoesCreateOrConnectWithoutUserInput[]
    upsert?: ShoesUpsertWithWhereUniqueWithoutUserInput | ShoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShoesCreateManyUserInputEnvelope
    set?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    disconnect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    delete?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    connect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    update?: ShoesUpdateWithWhereUniqueWithoutUserInput | ShoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShoesUpdateManyWithWhereWithoutUserInput | ShoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShoesScalarWhereInput | ShoesScalarWhereInput[]
  }

  export type AccessoriesUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput> | AccessoriesCreateWithoutUserInput[] | AccessoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessoriesCreateOrConnectWithoutUserInput | AccessoriesCreateOrConnectWithoutUserInput[]
    upsert?: AccessoriesUpsertWithWhereUniqueWithoutUserInput | AccessoriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessoriesCreateManyUserInputEnvelope
    set?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    disconnect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    delete?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    connect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    update?: AccessoriesUpdateWithWhereUniqueWithoutUserInput | AccessoriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessoriesUpdateManyWithWhereWithoutUserInput | AccessoriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessoriesScalarWhereInput | AccessoriesScalarWhereInput[]
  }

  export type AccsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput> | AccsCreateWithoutUserInput[] | AccsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccsCreateOrConnectWithoutUserInput | AccsCreateOrConnectWithoutUserInput[]
    upsert?: AccsUpsertWithWhereUniqueWithoutUserInput | AccsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccsCreateManyUserInputEnvelope
    set?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    disconnect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    delete?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    connect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    update?: AccsUpdateWithWhereUniqueWithoutUserInput | AccsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccsUpdateManyWithWhereWithoutUserInput | AccsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccsScalarWhereInput | AccsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TopsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput> | TopsCreateWithoutUserInput[] | TopsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopsCreateOrConnectWithoutUserInput | TopsCreateOrConnectWithoutUserInput[]
    upsert?: TopsUpsertWithWhereUniqueWithoutUserInput | TopsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopsCreateManyUserInputEnvelope
    set?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    disconnect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    delete?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    connect?: TopsWhereUniqueInput | TopsWhereUniqueInput[]
    update?: TopsUpdateWithWhereUniqueWithoutUserInput | TopsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopsUpdateManyWithWhereWithoutUserInput | TopsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopsScalarWhereInput | TopsScalarWhereInput[]
  }

  export type BottomsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput> | BottomsCreateWithoutUserInput[] | BottomsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BottomsCreateOrConnectWithoutUserInput | BottomsCreateOrConnectWithoutUserInput[]
    upsert?: BottomsUpsertWithWhereUniqueWithoutUserInput | BottomsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BottomsCreateManyUserInputEnvelope
    set?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    disconnect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    delete?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    connect?: BottomsWhereUniqueInput | BottomsWhereUniqueInput[]
    update?: BottomsUpdateWithWhereUniqueWithoutUserInput | BottomsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BottomsUpdateManyWithWhereWithoutUserInput | BottomsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BottomsScalarWhereInput | BottomsScalarWhereInput[]
  }

  export type ShoesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput> | ShoesCreateWithoutUserInput[] | ShoesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoesCreateOrConnectWithoutUserInput | ShoesCreateOrConnectWithoutUserInput[]
    upsert?: ShoesUpsertWithWhereUniqueWithoutUserInput | ShoesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShoesCreateManyUserInputEnvelope
    set?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    disconnect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    delete?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    connect?: ShoesWhereUniqueInput | ShoesWhereUniqueInput[]
    update?: ShoesUpdateWithWhereUniqueWithoutUserInput | ShoesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShoesUpdateManyWithWhereWithoutUserInput | ShoesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShoesScalarWhereInput | ShoesScalarWhereInput[]
  }

  export type AccessoriesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput> | AccessoriesCreateWithoutUserInput[] | AccessoriesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessoriesCreateOrConnectWithoutUserInput | AccessoriesCreateOrConnectWithoutUserInput[]
    upsert?: AccessoriesUpsertWithWhereUniqueWithoutUserInput | AccessoriesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessoriesCreateManyUserInputEnvelope
    set?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    disconnect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    delete?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    connect?: AccessoriesWhereUniqueInput | AccessoriesWhereUniqueInput[]
    update?: AccessoriesUpdateWithWhereUniqueWithoutUserInput | AccessoriesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessoriesUpdateManyWithWhereWithoutUserInput | AccessoriesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessoriesScalarWhereInput | AccessoriesScalarWhereInput[]
  }

  export type AccsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput> | AccsCreateWithoutUserInput[] | AccsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccsCreateOrConnectWithoutUserInput | AccsCreateOrConnectWithoutUserInput[]
    upsert?: AccsUpsertWithWhereUniqueWithoutUserInput | AccsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccsCreateManyUserInputEnvelope
    set?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    disconnect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    delete?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    connect?: AccsWhereUniqueInput | AccsWhereUniqueInput[]
    update?: AccsUpdateWithWhereUniqueWithoutUserInput | AccsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccsUpdateManyWithWhereWithoutUserInput | AccsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccsScalarWhereInput | AccsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTopsInput = {
    create?: XOR<UserCreateWithoutTopsInput, UserUncheckedCreateWithoutTopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTopsNestedInput = {
    create?: XOR<UserCreateWithoutTopsInput, UserUncheckedCreateWithoutTopsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopsInput
    upsert?: UserUpsertWithoutTopsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopsInput, UserUpdateWithoutTopsInput>, UserUncheckedUpdateWithoutTopsInput>
  }

  export type UserCreateNestedOneWithoutBottomsInput = {
    create?: XOR<UserCreateWithoutBottomsInput, UserUncheckedCreateWithoutBottomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBottomsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBottomsNestedInput = {
    create?: XOR<UserCreateWithoutBottomsInput, UserUncheckedCreateWithoutBottomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBottomsInput
    upsert?: UserUpsertWithoutBottomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBottomsInput, UserUpdateWithoutBottomsInput>, UserUncheckedUpdateWithoutBottomsInput>
  }

  export type UserCreateNestedOneWithoutShoesInput = {
    create?: XOR<UserCreateWithoutShoesInput, UserUncheckedCreateWithoutShoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShoesNestedInput = {
    create?: XOR<UserCreateWithoutShoesInput, UserUncheckedCreateWithoutShoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoesInput
    upsert?: UserUpsertWithoutShoesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShoesInput, UserUpdateWithoutShoesInput>, UserUncheckedUpdateWithoutShoesInput>
  }

  export type UserCreateNestedOneWithoutAccessoriesInput = {
    create?: XOR<UserCreateWithoutAccessoriesInput, UserUncheckedCreateWithoutAccessoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccessoriesNestedInput = {
    create?: XOR<UserCreateWithoutAccessoriesInput, UserUncheckedCreateWithoutAccessoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccessoriesInput
    upsert?: UserUpsertWithoutAccessoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccessoriesInput, UserUpdateWithoutAccessoriesInput>, UserUncheckedUpdateWithoutAccessoriesInput>
  }

  export type UserCreateNestedOneWithoutAccsInput = {
    create?: XOR<UserCreateWithoutAccsInput, UserUncheckedCreateWithoutAccsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccsNestedInput = {
    create?: XOR<UserCreateWithoutAccsInput, UserUncheckedCreateWithoutAccsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccsInput
    upsert?: UserUpsertWithoutAccsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccsInput, UserUpdateWithoutAccsInput>, UserUncheckedUpdateWithoutAccsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type TopsCreateWithoutUserInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type TopsUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type TopsCreateOrConnectWithoutUserInput = {
    where: TopsWhereUniqueInput
    create: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput>
  }

  export type TopsCreateManyUserInputEnvelope = {
    data: TopsCreateManyUserInput | TopsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BottomsCreateWithoutUserInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type BottomsUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type BottomsCreateOrConnectWithoutUserInput = {
    where: BottomsWhereUniqueInput
    create: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput>
  }

  export type BottomsCreateManyUserInputEnvelope = {
    data: BottomsCreateManyUserInput | BottomsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShoesCreateWithoutUserInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type ShoesUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type ShoesCreateOrConnectWithoutUserInput = {
    where: ShoesWhereUniqueInput
    create: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput>
  }

  export type ShoesCreateManyUserInputEnvelope = {
    data: ShoesCreateManyUserInput | ShoesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccessoriesCreateWithoutUserInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccessoriesUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccessoriesCreateOrConnectWithoutUserInput = {
    where: AccessoriesWhereUniqueInput
    create: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput>
  }

  export type AccessoriesCreateManyUserInputEnvelope = {
    data: AccessoriesCreateManyUserInput | AccessoriesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccsCreateWithoutUserInput = {
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccsUncheckedCreateWithoutUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccsCreateOrConnectWithoutUserInput = {
    where: AccsWhereUniqueInput
    create: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput>
  }

  export type AccsCreateManyUserInputEnvelope = {
    data: AccsCreateManyUserInput | AccsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TopsUpsertWithWhereUniqueWithoutUserInput = {
    where: TopsWhereUniqueInput
    update: XOR<TopsUpdateWithoutUserInput, TopsUncheckedUpdateWithoutUserInput>
    create: XOR<TopsCreateWithoutUserInput, TopsUncheckedCreateWithoutUserInput>
  }

  export type TopsUpdateWithWhereUniqueWithoutUserInput = {
    where: TopsWhereUniqueInput
    data: XOR<TopsUpdateWithoutUserInput, TopsUncheckedUpdateWithoutUserInput>
  }

  export type TopsUpdateManyWithWhereWithoutUserInput = {
    where: TopsScalarWhereInput
    data: XOR<TopsUpdateManyMutationInput, TopsUncheckedUpdateManyWithoutUserInput>
  }

  export type TopsScalarWhereInput = {
    AND?: TopsScalarWhereInput | TopsScalarWhereInput[]
    OR?: TopsScalarWhereInput[]
    NOT?: TopsScalarWhereInput | TopsScalarWhereInput[]
    id?: IntFilter<"Tops"> | number
    user_id?: IntFilter<"Tops"> | number
    name?: StringNullableFilter<"Tops"> | string | null
    description?: StringNullableFilter<"Tops"> | string | null
    url?: StringFilter<"Tops"> | string
    brand?: StringNullableFilter<"Tops"> | string | null
    color?: StringNullableFilter<"Tops"> | string | null
    size?: StringNullableFilter<"Tops"> | string | null
    occasion?: StringNullableFilter<"Tops"> | string | null
    material?: StringNullableFilter<"Tops"> | string | null
  }

  export type BottomsUpsertWithWhereUniqueWithoutUserInput = {
    where: BottomsWhereUniqueInput
    update: XOR<BottomsUpdateWithoutUserInput, BottomsUncheckedUpdateWithoutUserInput>
    create: XOR<BottomsCreateWithoutUserInput, BottomsUncheckedCreateWithoutUserInput>
  }

  export type BottomsUpdateWithWhereUniqueWithoutUserInput = {
    where: BottomsWhereUniqueInput
    data: XOR<BottomsUpdateWithoutUserInput, BottomsUncheckedUpdateWithoutUserInput>
  }

  export type BottomsUpdateManyWithWhereWithoutUserInput = {
    where: BottomsScalarWhereInput
    data: XOR<BottomsUpdateManyMutationInput, BottomsUncheckedUpdateManyWithoutUserInput>
  }

  export type BottomsScalarWhereInput = {
    AND?: BottomsScalarWhereInput | BottomsScalarWhereInput[]
    OR?: BottomsScalarWhereInput[]
    NOT?: BottomsScalarWhereInput | BottomsScalarWhereInput[]
    id?: IntFilter<"Bottoms"> | number
    user_id?: IntFilter<"Bottoms"> | number
    name?: StringNullableFilter<"Bottoms"> | string | null
    description?: StringNullableFilter<"Bottoms"> | string | null
    url?: StringFilter<"Bottoms"> | string
    brand?: StringNullableFilter<"Bottoms"> | string | null
    color?: StringNullableFilter<"Bottoms"> | string | null
    size?: StringNullableFilter<"Bottoms"> | string | null
    occasion?: StringNullableFilter<"Bottoms"> | string | null
    material?: StringNullableFilter<"Bottoms"> | string | null
  }

  export type ShoesUpsertWithWhereUniqueWithoutUserInput = {
    where: ShoesWhereUniqueInput
    update: XOR<ShoesUpdateWithoutUserInput, ShoesUncheckedUpdateWithoutUserInput>
    create: XOR<ShoesCreateWithoutUserInput, ShoesUncheckedCreateWithoutUserInput>
  }

  export type ShoesUpdateWithWhereUniqueWithoutUserInput = {
    where: ShoesWhereUniqueInput
    data: XOR<ShoesUpdateWithoutUserInput, ShoesUncheckedUpdateWithoutUserInput>
  }

  export type ShoesUpdateManyWithWhereWithoutUserInput = {
    where: ShoesScalarWhereInput
    data: XOR<ShoesUpdateManyMutationInput, ShoesUncheckedUpdateManyWithoutUserInput>
  }

  export type ShoesScalarWhereInput = {
    AND?: ShoesScalarWhereInput | ShoesScalarWhereInput[]
    OR?: ShoesScalarWhereInput[]
    NOT?: ShoesScalarWhereInput | ShoesScalarWhereInput[]
    id?: IntFilter<"Shoes"> | number
    user_id?: IntFilter<"Shoes"> | number
    name?: StringNullableFilter<"Shoes"> | string | null
    description?: StringNullableFilter<"Shoes"> | string | null
    url?: StringFilter<"Shoes"> | string
    brand?: StringNullableFilter<"Shoes"> | string | null
    color?: StringNullableFilter<"Shoes"> | string | null
    size?: StringNullableFilter<"Shoes"> | string | null
    occasion?: StringNullableFilter<"Shoes"> | string | null
    material?: StringNullableFilter<"Shoes"> | string | null
  }

  export type AccessoriesUpsertWithWhereUniqueWithoutUserInput = {
    where: AccessoriesWhereUniqueInput
    update: XOR<AccessoriesUpdateWithoutUserInput, AccessoriesUncheckedUpdateWithoutUserInput>
    create: XOR<AccessoriesCreateWithoutUserInput, AccessoriesUncheckedCreateWithoutUserInput>
  }

  export type AccessoriesUpdateWithWhereUniqueWithoutUserInput = {
    where: AccessoriesWhereUniqueInput
    data: XOR<AccessoriesUpdateWithoutUserInput, AccessoriesUncheckedUpdateWithoutUserInput>
  }

  export type AccessoriesUpdateManyWithWhereWithoutUserInput = {
    where: AccessoriesScalarWhereInput
    data: XOR<AccessoriesUpdateManyMutationInput, AccessoriesUncheckedUpdateManyWithoutUserInput>
  }

  export type AccessoriesScalarWhereInput = {
    AND?: AccessoriesScalarWhereInput | AccessoriesScalarWhereInput[]
    OR?: AccessoriesScalarWhereInput[]
    NOT?: AccessoriesScalarWhereInput | AccessoriesScalarWhereInput[]
    id?: IntFilter<"Accessories"> | number
    user_id?: IntFilter<"Accessories"> | number
    name?: StringNullableFilter<"Accessories"> | string | null
    description?: StringNullableFilter<"Accessories"> | string | null
    url?: StringFilter<"Accessories"> | string
    brand?: StringNullableFilter<"Accessories"> | string | null
    color?: StringNullableFilter<"Accessories"> | string | null
    size?: StringNullableFilter<"Accessories"> | string | null
    occasion?: StringNullableFilter<"Accessories"> | string | null
    material?: StringNullableFilter<"Accessories"> | string | null
  }

  export type AccsUpsertWithWhereUniqueWithoutUserInput = {
    where: AccsWhereUniqueInput
    update: XOR<AccsUpdateWithoutUserInput, AccsUncheckedUpdateWithoutUserInput>
    create: XOR<AccsCreateWithoutUserInput, AccsUncheckedCreateWithoutUserInput>
  }

  export type AccsUpdateWithWhereUniqueWithoutUserInput = {
    where: AccsWhereUniqueInput
    data: XOR<AccsUpdateWithoutUserInput, AccsUncheckedUpdateWithoutUserInput>
  }

  export type AccsUpdateManyWithWhereWithoutUserInput = {
    where: AccsScalarWhereInput
    data: XOR<AccsUpdateManyMutationInput, AccsUncheckedUpdateManyWithoutUserInput>
  }

  export type AccsScalarWhereInput = {
    AND?: AccsScalarWhereInput | AccsScalarWhereInput[]
    OR?: AccsScalarWhereInput[]
    NOT?: AccsScalarWhereInput | AccsScalarWhereInput[]
    id?: IntFilter<"Accs"> | number
    user_id?: IntFilter<"Accs"> | number
    name?: StringNullableFilter<"Accs"> | string | null
    description?: StringNullableFilter<"Accs"> | string | null
    url?: StringFilter<"Accs"> | string
    brand?: StringNullableFilter<"Accs"> | string | null
    color?: StringNullableFilter<"Accs"> | string | null
    size?: StringNullableFilter<"Accs"> | string | null
    occasion?: StringNullableFilter<"Accs"> | string | null
    material?: StringNullableFilter<"Accs"> | string | null
  }

  export type UserCreateWithoutTopsInput = {
    name?: string | null
    email: string
    password?: string | null
    bottoms?: BottomsCreateNestedManyWithoutUserInput
    shoes?: ShoesCreateNestedManyWithoutUserInput
    accessories?: AccessoriesCreateNestedManyWithoutUserInput
    accs?: AccsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopsInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    bottoms?: BottomsUncheckedCreateNestedManyWithoutUserInput
    shoes?: ShoesUncheckedCreateNestedManyWithoutUserInput
    accessories?: AccessoriesUncheckedCreateNestedManyWithoutUserInput
    accs?: AccsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopsInput, UserUncheckedCreateWithoutTopsInput>
  }

  export type UserUpsertWithoutTopsInput = {
    update: XOR<UserUpdateWithoutTopsInput, UserUncheckedUpdateWithoutTopsInput>
    create: XOR<UserCreateWithoutTopsInput, UserUncheckedCreateWithoutTopsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopsInput, UserUncheckedUpdateWithoutTopsInput>
  }

  export type UserUpdateWithoutTopsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    bottoms?: BottomsUpdateManyWithoutUserNestedInput
    shoes?: ShoesUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUpdateManyWithoutUserNestedInput
    accs?: AccsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    bottoms?: BottomsUncheckedUpdateManyWithoutUserNestedInput
    shoes?: ShoesUncheckedUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUncheckedUpdateManyWithoutUserNestedInput
    accs?: AccsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutBottomsInput = {
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsCreateNestedManyWithoutUserInput
    shoes?: ShoesCreateNestedManyWithoutUserInput
    accessories?: AccessoriesCreateNestedManyWithoutUserInput
    accs?: AccsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBottomsInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsUncheckedCreateNestedManyWithoutUserInput
    shoes?: ShoesUncheckedCreateNestedManyWithoutUserInput
    accessories?: AccessoriesUncheckedCreateNestedManyWithoutUserInput
    accs?: AccsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBottomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBottomsInput, UserUncheckedCreateWithoutBottomsInput>
  }

  export type UserUpsertWithoutBottomsInput = {
    update: XOR<UserUpdateWithoutBottomsInput, UserUncheckedUpdateWithoutBottomsInput>
    create: XOR<UserCreateWithoutBottomsInput, UserUncheckedCreateWithoutBottomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBottomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBottomsInput, UserUncheckedUpdateWithoutBottomsInput>
  }

  export type UserUpdateWithoutBottomsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUpdateManyWithoutUserNestedInput
    shoes?: ShoesUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUpdateManyWithoutUserNestedInput
    accs?: AccsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBottomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUncheckedUpdateManyWithoutUserNestedInput
    shoes?: ShoesUncheckedUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUncheckedUpdateManyWithoutUserNestedInput
    accs?: AccsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutShoesInput = {
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsCreateNestedManyWithoutUserInput
    bottoms?: BottomsCreateNestedManyWithoutUserInput
    accessories?: AccessoriesCreateNestedManyWithoutUserInput
    accs?: AccsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShoesInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsUncheckedCreateNestedManyWithoutUserInput
    bottoms?: BottomsUncheckedCreateNestedManyWithoutUserInput
    accessories?: AccessoriesUncheckedCreateNestedManyWithoutUserInput
    accs?: AccsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShoesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShoesInput, UserUncheckedCreateWithoutShoesInput>
  }

  export type UserUpsertWithoutShoesInput = {
    update: XOR<UserUpdateWithoutShoesInput, UserUncheckedUpdateWithoutShoesInput>
    create: XOR<UserCreateWithoutShoesInput, UserUncheckedCreateWithoutShoesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShoesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShoesInput, UserUncheckedUpdateWithoutShoesInput>
  }

  export type UserUpdateWithoutShoesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUpdateManyWithoutUserNestedInput
    accs?: AccsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUncheckedUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUncheckedUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUncheckedUpdateManyWithoutUserNestedInput
    accs?: AccsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccessoriesInput = {
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsCreateNestedManyWithoutUserInput
    bottoms?: BottomsCreateNestedManyWithoutUserInput
    shoes?: ShoesCreateNestedManyWithoutUserInput
    accs?: AccsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccessoriesInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsUncheckedCreateNestedManyWithoutUserInput
    bottoms?: BottomsUncheckedCreateNestedManyWithoutUserInput
    shoes?: ShoesUncheckedCreateNestedManyWithoutUserInput
    accs?: AccsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccessoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccessoriesInput, UserUncheckedCreateWithoutAccessoriesInput>
  }

  export type UserUpsertWithoutAccessoriesInput = {
    update: XOR<UserUpdateWithoutAccessoriesInput, UserUncheckedUpdateWithoutAccessoriesInput>
    create: XOR<UserCreateWithoutAccessoriesInput, UserUncheckedCreateWithoutAccessoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccessoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccessoriesInput, UserUncheckedUpdateWithoutAccessoriesInput>
  }

  export type UserUpdateWithoutAccessoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUpdateManyWithoutUserNestedInput
    shoes?: ShoesUpdateManyWithoutUserNestedInput
    accs?: AccsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccessoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUncheckedUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUncheckedUpdateManyWithoutUserNestedInput
    shoes?: ShoesUncheckedUpdateManyWithoutUserNestedInput
    accs?: AccsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccsInput = {
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsCreateNestedManyWithoutUserInput
    bottoms?: BottomsCreateNestedManyWithoutUserInput
    shoes?: ShoesCreateNestedManyWithoutUserInput
    accessories?: AccessoriesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccsInput = {
    id?: number
    name?: string | null
    email: string
    password?: string | null
    tops?: TopsUncheckedCreateNestedManyWithoutUserInput
    bottoms?: BottomsUncheckedCreateNestedManyWithoutUserInput
    shoes?: ShoesUncheckedCreateNestedManyWithoutUserInput
    accessories?: AccessoriesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccsInput, UserUncheckedCreateWithoutAccsInput>
  }

  export type UserUpsertWithoutAccsInput = {
    update: XOR<UserUpdateWithoutAccsInput, UserUncheckedUpdateWithoutAccsInput>
    create: XOR<UserCreateWithoutAccsInput, UserUncheckedCreateWithoutAccsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccsInput, UserUncheckedUpdateWithoutAccsInput>
  }

  export type UserUpdateWithoutAccsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUpdateManyWithoutUserNestedInput
    shoes?: ShoesUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    tops?: TopsUncheckedUpdateManyWithoutUserNestedInput
    bottoms?: BottomsUncheckedUpdateManyWithoutUserNestedInput
    shoes?: ShoesUncheckedUpdateManyWithoutUserNestedInput
    accessories?: AccessoriesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TopsCreateManyUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type BottomsCreateManyUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type ShoesCreateManyUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccessoriesCreateManyUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type AccsCreateManyUserInput = {
    id?: number
    name?: string | null
    description?: string | null
    url: string
    brand?: string | null
    color?: string | null
    size?: string | null
    occasion?: string | null
    material?: string | null
  }

  export type TopsUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TopsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BottomsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShoesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessoriesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    occasion?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TopsDefaultArgs instead
     */
    export type TopsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = TopsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BottomsDefaultArgs instead
     */
    export type BottomsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BottomsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShoesDefaultArgs instead
     */
    export type ShoesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ShoesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccessoriesDefaultArgs instead
     */
    export type AccessoriesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AccessoriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccsDefaultArgs instead
     */
    export type AccsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AccsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}